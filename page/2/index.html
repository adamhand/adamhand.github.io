<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Dethnote">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Dethnote">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dethnote">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>Dethnote</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dethnote</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/01/时间口袋/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="adamhand">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dethnote">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/01/时间口袋/" itemprop="url">时间口袋</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-01T10:28:59+08:00">
                2019-01-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/诗/" itemprop="url" rel="index">
                    <span itemprop="name">诗</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>时间口袋</strong></p>
<p>我的时间是一只口袋<br>空闲的时候  口袋是空的<br>这时 你便趁机往里钻<br>你是泡沫  让口袋膨胀变得无意义</p>
<p>于是我用力扎紧口袋口<br>得意地以为这次你再也无机可乘了<br>可当我回过神来<br>发现你又变成了无孔不入的风<br>正从我手指的缝隙间钻进去</p>
<p>于是  我把口袋中装满乱七八糟的东西<br>读书  工作  跑步  听歌  满满当当的<br>终于<br>这下子再也没有你的位置了</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/31/慎用异或-的方式交换两个数的值/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="adamhand">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dethnote">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/31/慎用异或-的方式交换两个数的值/" itemprop="url">慎用异或(^)的方式交换两个数的值</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-31T22:57:03+08:00">
                2018-12-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/杂/" itemprop="url" rel="index">
                    <span itemprop="name">杂</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一般认为用异或的方式交换两个数的值不需要辅助空间，面试的时候是个好说法。但是这种方法却不很实用，因为有时候使用异或的方式交换两个数的值会出现错误的情况，下面举个例子。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min ;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            min = i;                                 <span class="comment">//记录最小元素的位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[min]) &#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nums[i] = nums[i] ^ nums[min];</span><br><span class="line">            nums[min] = nums[i] ^ nums[min];</span><br><span class="line">            nums[i] = nums[i] ^ nums[min];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">34</span>, <span class="number">19</span>, <span class="number">11</span>, <span class="number">109</span>, <span class="number">3</span>, <span class="number">56</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            System.out.print(nums[i]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        SelectionSort.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            System.out.print(nums[i]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>例如上面这个例子，是一个快速排序的算法。该程序的输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">34 19 11 109 3 56 </span><br><span class="line">3 11 0 34 56 109</span><br></pre></td></tr></table></figure></p>
<p>可以看到，排序之后的19变成0了。问题就出在异或的地方。因为在其中一次循环完成之后，<code>min=i=2</code>，这时执行异或的语句就相当于<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums[<span class="number">2</span>] = nums[<span class="number">2</span>] ^ nums[<span class="number">2</span>];            <span class="comment">//结果为0</span></span><br><span class="line">nums[<span class="number">2</span>] = nums[<span class="number">2</span>] ^ nums[<span class="number">2</span>];            <span class="comment">//结果为0</span></span><br><span class="line">nums[<span class="number">2</span>] = nums[<span class="number">2</span>] ^ nums[<span class="number">2</span>];            <span class="comment">//结果为0</span></span><br></pre></td></tr></table></figure></p>
<p>就出现了错误。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/31/LeetCode笔记之数组-1/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="adamhand">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dethnote">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/31/LeetCode笔记之数组-1/" itemprop="url">LeetCode笔记之数组(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-31T22:52:59+08:00">
                2018-12-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="LeetCode笔记之数组-一"><a href="#LeetCode笔记之数组-一" class="headerlink" title="LeetCode笔记之数组(一)"></a>LeetCode笔记之数组(一)</h1><hr>
<h1 id="1-Sum"><a href="#1-Sum" class="headerlink" title="1. Sum"></a>1. Sum</h1><h2 id="1-1-Two-Sum"><a href="#1-1-Two-Sum" class="headerlink" title="1.1 Two Sum"></a>1.1 Two Sum</h2><center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/TwoSum.PNG"><br></center>

<ul>
<li>解法1:最容易想到的方法就是两个for循环嵌套，但这显然不是最简单的方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        for(int i = 0; i &lt; nums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = i + 1; j &lt; nums.length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(nums[i] + nums[j] == target)</span><br><span class="line">                &#123;</span><br><span class="line">                    return new int[] &#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new IllegalArgumentException(&quot;No two sum solution&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法2:使用HashMap存储键值对信息，其中”值”就是题目中要返回的”位置”。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    for(int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">        int component = target - nums[i];    //需要构造一个A+B=target的关系</span><br><span class="line">        if(!map.containsKey(component))&#123;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return new int[] &#123;map.get(component), i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    throw new IllegalArgumentException(&quot;no solution&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法3:使用<strong><em>双指针</em></strong>。但是这种方法需要对数组进行排序，改变了原来的位置，而题目要求返回的是位置而不是数，所以这个方法并不适合与该题。如果题目要求返回的是数，可以用这种方法。<br>解法的思路如下：首先对输入的数组有小到大进行排序，然后用两个指针分别从数组头和数组尾开始遍历，如果两个数的和正好等于target就返回（因为题目表明如果有满足条件的数，只能有一组）；如果两数之和小于target，让左指针加一，反之右指针加一。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//这里要求返回位置而不是数，所以这种方法不能用，因为排了序，位置改变了</span><br><span class="line">public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    int lo = 0, hi = nums.length - 1;</span><br><span class="line">    while(lo &lt; hi)&#123;</span><br><span class="line">        if(nums[lo] + nums[hi] == target)&#123;</span><br><span class="line">            //return new int[]&#123;nums[lo], nums[hi]&#125;;</span><br><span class="line">            return new int[] &#123;lo, hi&#125;;</span><br><span class="line">        &#125;else if(nums[lo] + nums[hi] &lt; target)&#123;</span><br><span class="line">            while(lo &lt; hi &amp;&amp; nums[lo] == nums[lo+1]) lo++;  //如果有重复元素就跳过</span><br><span class="line">            lo++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            while(lo &lt; hi &amp;&amp; nums[hi] == nums[hi-1]) hi--;</span><br><span class="line">            hi--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    throw new IllegalArgumentException(&quot;no solution&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-ThreeSum"><a href="#1-2-ThreeSum" class="headerlink" title="1.2 ThreeSum"></a>1.2 ThreeSum</h2><center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/ThreeSum.PNG"><br></center>

<ul>
<li>解法:和TwoSum的思想类似，利用双指针，首先固定一个数nums[i]，然后改变另外两个数nums[lo]和nums[hi]。这里需要注意的是，for循环的边界条件nums.length-2是怎么确定的，当i=nums.length-3时，lo=nums.length-2,hi=nums.length-1，三个数正好是数组最后面的三位数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();</span><br><span class="line">    for(int i = 0; i &lt; nums.length - 2; i++)&#123;</span><br><span class="line">        if(i == 0 || (i &gt; 0 &amp;&amp; nums[i] != nums[i-1]))&#123;</span><br><span class="line">            int lo = i+1, hi = nums.length-1, sum = 0-nums[i];</span><br><span class="line">            while(lo &lt; hi)&#123;</span><br><span class="line">                if(nums[lo] +nums[hi] == sum)&#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i], nums[lo], nums[hi]));</span><br><span class="line">                    while(lo &lt; hi &amp;&amp; nums[lo] == nums[lo+1]) lo++;  //题目要求，元素不能重复</span><br><span class="line">                    while(lo &lt; hi &amp;&amp; nums[hi] == nums[hi-1]) hi--;</span><br><span class="line">                    lo++;</span><br><span class="line">                    hi--;</span><br><span class="line">                &#125;else if(nums[lo] + nums[hi] &lt; sum)&#123;</span><br><span class="line">                    lo++;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    hi--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-ThreeSumClosest"><a href="#1-3-ThreeSumClosest" class="headerlink" title="1.3 ThreeSumClosest"></a>1.3 ThreeSumClosest</h2><center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/ThreeSumClosest.PNG"><br></center>

<ul>
<li>解法1:借鉴ThreeSum的思想。有一点需要理解，在数学上，绝对值表示”距离”，所以第11行的语句<br>ans = (Math.abs(target-sum) &gt; Math.abs(target-ans)) ? ans : sum;<br>意思是比较target到sum的距离和target到ans的距离，取小值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public int threeSumClosest(int[] nums, int target) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    //int ans = Integer.MAX_VALUE;</span><br><span class="line">    int ans = nums[0] + nums[1] + nums[nums.length-1];</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    for(int i = 0; i &lt; nums.length-2; i++)&#123;</span><br><span class="line">        int lo = i+1, hi = nums.length-1;</span><br><span class="line">        // sum = nums[i] + nums[lo] + nums[hi];</span><br><span class="line">        while(lo &lt; hi)&#123;</span><br><span class="line">            sum = nums[i] + nums[lo] + nums[hi];</span><br><span class="line">            ans = (Math.abs(target-sum) &gt; Math.abs(target-ans)) ? ans : sum;</span><br><span class="line">            if(sum == target)&#123;</span><br><span class="line">                return target;</span><br><span class="line">            &#125;else if(sum &lt; target)&#123;</span><br><span class="line">                while(lo &lt; hi &amp;&amp; nums[lo] == nums[lo+1]) lo++;</span><br><span class="line">                lo++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                while(lo &lt; hi &amp;&amp; nums[hi] == nums[hi-1]) hi--;</span><br><span class="line">                hi--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法2:和解法1思想一样，但是简洁一些</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int threeSumClosest(int[] num, int target) &#123;</span><br><span class="line">    int result = num[0] + num[1] + num[num.length - 1];</span><br><span class="line">    Arrays.sort(num);</span><br><span class="line">    for (int i = 0; i &lt; num.length - 2; i++) &#123;</span><br><span class="line">        int start = i + 1, end = num.length - 1;</span><br><span class="line">        while (start &lt; end) &#123;</span><br><span class="line">            int sum = num[i] + num[start] + num[end];</span><br><span class="line">            if (sum &gt; target) &#123;</span><br><span class="line">                end--;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (Math.abs(sum - target) &lt; Math.abs(result - target)) &#123;</span><br><span class="line">                result = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-4-FourSum"><a href="#1-4-FourSum" class="headerlink" title="1.4 FourSum"></a>1.4 FourSum</h2><center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/FourSum.PNG"><br></center>

<ul>
<li>解法：从towsum到threeesum可以看出一些规律，可以用递归的方式解决xSum的问题。这是因为kSum的问题可以分解成两个问题：<ul>
<li>twoSum问题</li>
<li>将K sum问题简化为K-1 sum问题</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        len = nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> kSum(nums, target, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">private</span> ArrayList&lt;List&lt;Integer&gt;&gt; kSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> k, <span class="keyword">int</span> index) &#123;</span><br><span class="line">        ArrayList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= len) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">2</span>) &#123;</span><br><span class="line">        	<span class="keyword">int</span> i = index, j = len - <span class="number">1</span>;</span><br><span class="line">        	<span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">                <span class="comment">//find a pair</span></span><br><span class="line">        	    <span class="keyword">if</span>(target - nums[i] == nums[j]) &#123;</span><br><span class="line">        	    	List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                	temp.add(nums[i]);</span><br><span class="line">                	temp.add(target-nums[i]);</span><br><span class="line">                    res.add(temp);</span><br><span class="line">                    <span class="comment">//skip duplication</span></span><br><span class="line">                    <span class="keyword">while</span>(i&lt;j &amp;&amp; nums[i]==nums[i+<span class="number">1</span>]) i++;</span><br><span class="line">                    <span class="keyword">while</span>(i&lt;j &amp;&amp; nums[j-<span class="number">1</span>]==nums[j]) j--;</span><br><span class="line">                    i++;</span><br><span class="line">                    j--;</span><br><span class="line">                <span class="comment">//move left bound</span></span><br><span class="line">        	    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target - nums[i] &gt; nums[j]) &#123;</span><br><span class="line">        	        i++;</span><br><span class="line">                <span class="comment">//move right bound</span></span><br><span class="line">        	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	        j--;</span><br><span class="line">        	    &#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; len - k + <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//use current number to reduce ksum into k-1sum</span></span><br><span class="line">                ArrayList&lt;List&lt;Integer&gt;&gt; temp = kSum(nums, target - nums[i], k-<span class="number">1</span>, i+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(temp != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//add previous results</span></span><br><span class="line">                    <span class="keyword">for</span> (List&lt;Integer&gt; t : temp) &#123;</span><br><span class="line">                        t.add(<span class="number">0</span>, nums[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    res.addAll(temp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; len-<span class="number">1</span> &amp;&amp; nums[i] == nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">//skip duplicated numbers</span></span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-5-FourSum-II"><a href="#1-5-FourSum-II" class="headerlink" title="1.5 FourSum II"></a>1.5 FourSum II</h2><center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/FourSum%20II.PNG"><br></center>

<p>看到这个问题时，最先想到的方法就是暴力法，四个for循环嵌套，但可想而知算法的速度是多么慢解决这种复杂问题的一个思路就是<strong><em>分治</em></strong>，把复杂问题分解成几个比较简单的问题。</p>
<ul>
<li>解法1：使用HashMap。首先将数组A和数组B中元素的所有可能的和算出来，放入hashmp中，如果某个和出现多于一次，每出现一次就将其出现的次数加一；否则将出现次数设置为一。然后将数组C和数组D中所有可能出现的和算出来并取相反数，和hashmap中的数比较，最终算出所有相同的数的个数，即为最终结果。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; sums = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.length; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = A[i] + B[j];</span><br><span class="line">                <span class="keyword">if</span>(sums.containsKey(sum))&#123;</span><br><span class="line">                    sums.put(sum, sums.get(sum)+<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    sums.put(sum, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; C.length; k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; D.length; v++)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = -(C[k] + D[v]);</span><br><span class="line">                <span class="keyword">if</span>(sums.containsKey(sum))&#123;</span><br><span class="line">                    count += sums.get(sum);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法1的简化写法，使用HashMap中的getOrDefault方法，这个方法有两个参数：getOrDefault(A, B)，参数A表示key值，参数B表示默认值。如果HashMap中包含该key值，就使用key值对应的value，否则就使用B。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; sums = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.length; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = A[i] + B[j];</span><br><span class="line">            sums.put(sum, sums.getOrDefault(sum, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; C.length; k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; D.length; v++)&#123;</span><br><span class="line">            count += sums.getOrDefault(-<span class="number">1</span> * (C[k]+D[v]), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法2：使用排序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nAB = A.length * B.length;</span><br><span class="line">    <span class="keyword">int</span>[] sumAB = <span class="keyword">new</span> <span class="keyword">int</span>[nAB];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a : A)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> b : B)&#123;</span><br><span class="line">            sumAB[i++] = a +b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nCD = C.length * D.length;</span><br><span class="line">    <span class="keyword">int</span>[] negSumCD = <span class="keyword">new</span> <span class="keyword">int</span>[nCD];</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> c : C)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> d : D)&#123;</span><br><span class="line">            negSumCD[i++] = -(c + d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Arrays.sort(sumAB);</span><br><span class="line">    Arrays.sort(negSumCD);</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; nAB &amp;&amp; j &lt; nCD)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sumAB[i] == negSumCD[j])&#123;</span><br><span class="line">            <span class="keyword">int</span> countAB = <span class="number">1</span>, countCD = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(++i &lt; nAB &amp;&amp; sumAB[i]==sumAB[i-<span class="number">1</span>]) countAB += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(++j &lt; nCD &amp;&amp; negSumCD[j]==negSumCD[j-<span class="number">1</span>]) countCD += <span class="number">1</span>;</span><br><span class="line">            count += countAB * countCD;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sumAB[i] &lt; negSumCD[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-Trapping-Water-盛水问题"><a href="#2-Trapping-Water-盛水问题" class="headerlink" title="2. Trapping  Water(盛水问题)"></a>2. Trapping  Water(盛水问题)</h1><h2 id="2-1-Trapping-Rain-Water"><a href="#2-1-Trapping-Rain-Water" class="headerlink" title="2.1 Trapping Rain Water"></a>2.1 Trapping Rain Water</h2><center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/trapping%20rain%20water.PNG"><br></center>

<ul>
<li>解法：这种问题的比较好的解决方法就是<strong><em>双指针法</em></strong>。需要注意的问题是，程序中<code>if(height[left] &lt; height[right])</code>这句话是关键，它比较出此时<code>left</code>指针和<code>right</code>指针指向的<code>height</code>的高度，然后移动高度小的指针。因为盛水多少是由<code>height</code>比较短的一端决定的。如果移动<code>height</code>比较长的指针，比如当<code>left</code>指向下标<code>3</code>而<code>right</code>指向下标<code>7</code>的时候，此时移动<code>right</code>，下一步就会执行<code>right_max - height[right]</code>出错，因为很明显水位没有到达此时<code>height[right]</code>的高度。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left_max = <span class="number">0</span>, right_max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right])&#123;</span><br><span class="line">                <span class="keyword">if</span>(height[left] &gt;= left_max)&#123;</span><br><span class="line">                    left_max = height[left];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans += left_max - height[left];</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(height[right] &gt;= right_max)&#123;</span><br><span class="line">                    right_max = height[right];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans += right_max - height[right];</span><br><span class="line">                &#125;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-Container-With-Most-Water"><a href="#2-2-Container-With-Most-Water" class="headerlink" title="2.2 Container With Most Water"></a>2.2 Container With Most Water</h2><center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/containing%20with%20most%20water.PNG"><br></center>

<ul>
<li>解法：这个题的思路和上个题目类似，不同的是需要移动<code>height</code>值较短的指针。</li>
</ul>
<p>假设现在有一个容器，则容器的盛水量取决于容器的底和容器较短的那条高。则我们可以从最大的底长入手，即当容器的底等于数组的长度时，则容器的盛水量为较短边的长乘底</p>
<p>可见 只有较短边会对盛水量造成影响，因此移动较短边的指针，并比较当前盛水量和当前最大盛水量。直至左右指针相遇。主要的困惑在于如何移动双指针才能保证最大的盛水量被遍历到</p>
<p>假设有左指针left和右指针right，且left指向的值小于right的值，假如我们将右指针左移，则右指针左移后的值和左指针指向的值相比有三种情况：</p>
<p>（1）右指针指向的值大于左指针<br>这种情况下，容器的高取决于左指针，但是底变短了，所以容器盛水量一定变小<br>（2）右指针指向的值等于左指针<br>这种情况下，容器的高取决于左指针，但是底变短了，所以容器盛水量一定变小<br>（3）右指针指向的值小于左指针<br>这种情况下，容器的高取决于右指针，但是右指针小于左指针，且底也变短了，所以容量盛水量一定变小了</p>
<p>综上所述，容器高度较大的一侧的移动只会造成容器盛水量减小。所以应当移动高度较小一侧的指针，并继续遍历，直至两指针相遇。</p>
<p><strong><em>更严谨的证明：反证法</em></strong><br>&emsp; 之前证明的只是在左指针不改变的情况下，左移右指针只会造成容器的容量减小。但是一旦紧接着左指针发生变化，就无法证明以该左指针为一侧高，右指针右侧的值生成的容器的容量比当前值小。<br>&emsp; 以下补充一个简单的反证法证明算法的合理性<br>&emsp; 当前的算法为：使用两个指针分别指向数组的头和尾。指向的值较小的那个指针移动，即左指针右移，右指针左移。当左右指针相遇时，<br>&emsp; 假设：该算法并没有遍历到容量最大的情况<br>&emsp; 我们令容量最大时的指针为p_left和p_right。根据题设，我们可以假设遍历时左指针先到达p_left，但是当左指针为p_left时，右指针还没有经过p_right左指针就移动了。<br>&emsp; 已知当左指针停留在p_left时，它只有在两种场景下会发生改变:</p>
<ul>
<li>左指针和右指针在p_left相遇，则右指针一定在前往p_left的途中经过p_right，与题设矛盾</li>
<li>右指针位于p_right右侧且当前的值大于左指针。则在这种情况下，此时容器的盛水量比题设中最大的盛水量还要大，与题设矛盾<br>因此该算法的遍历一定经过了最大的盛水量的情况<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, l = <span class="number">0</span>, r = height.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            max = Math.max(max, Math.min(height[l], height[r]) * (r - l));</span><br><span class="line">            <span class="keyword">if</span>(height[l] &lt; height[r])&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="3-Best-Time-to-Buy-and-Sell-利润最大问题"><a href="#3-Best-Time-to-Buy-and-Sell-利润最大问题" class="headerlink" title="3. Best Time to Buy and Sell(利润最大问题)"></a>3. Best Time to Buy and Sell(利润最大问题)</h1><h2 id="3-1-Best-Time-to-Buy-and-Sell-Stock"><a href="#3-1-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="3.1 Best Time to Buy and Sell Stock"></a>3.1 Best Time to Buy and Sell Stock</h2><p><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/best%20time%20to%20buy%20and%20sell%20stock.PNG" alt=""><br><strong><em>注意：</em></strong>题目中要求，只能进行一次交易。</p>
<ul>
<li>解法1：暴力循环。因为只能进行一次交易，只需找到满足条件(这里的条件值的是小值要在大值之前)的“最大值”和“最小值”即可。外层就是一个冒泡排序法的嵌套循环。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> prices[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; prices.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> profit = prices[j] - prices[i];</span><br><span class="line">                <span class="keyword">if</span> (profit &gt; maxprofit)</span><br><span class="line">                    maxprofit = profit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法2：一个窍门。方法一中暴力循环方法其实是用的冒泡排序法的思想，但是显然这里不需要排序，只需要找到最大值和最小值就行可以。先看下面的图：<center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/121_profit_graph.png"><br></center>

</li>
</ul>
<p>只需要找到“波峰”和“波谷”就行。可以定义两个变量<code>minprice</code>和<code>maxprofit</code>来解决这个问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> prices[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minprice = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; minprice)</span><br><span class="line">                minprice = prices[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (prices[i] - minprice &gt; maxprofit)</span><br><span class="line">                maxprofit = prices[i] - minprice;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#3-2-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="3.2 Best Time to Buy and Sell Stock II"></a>3.2 Best Time to Buy and Sell Stock II</h2><p><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/best%20time%20to%20buy%20and%20sell%20stock_2.PNG" alt=""><br><strong><em>注意：</em></strong>和上一个题目的不同之处在于可以进行多次买卖。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/31/《剑指offer》题目小结-1/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="adamhand">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dethnote">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/31/《剑指offer》题目小结-1/" itemprop="url">《剑指offer》题目小结(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-31T22:28:48+08:00">
                2018-12-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-数组中重复元素问题"><a href="#1-数组中重复元素问题" class="headerlink" title="1. 数组中重复元素问题"></a>1. 数组中重复元素问题</h1><h2 id="1-1-Find-All-Duplicates-in-an-Array"><a href="#1-1-Find-All-Duplicates-in-an-Array" class="headerlink" title="1.1 Find All Duplicates in an Array"></a>1.1 Find All Duplicates in an Array</h2><center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/find%20all%20duplicates%20in%20an%20array.PNG"><br></center>

<ul>
<li>解法：采用“置相反数”的方法，每知道一个<code>nums[i]</code>，就将下标为<code>nums[i]-1</code>的元素置为相反数(因为数组中的数是从1开始的，不用担心数组越界；且数的最大值为n，即总能找到位置)；然后判断下标为<code>nums[i]-1</code>处的数是否小于零，是的话，就表明该数之前已经出现过一次(如果没有重复的数，以其中一个数为下标只能找到一个位置，且仅有一个)。<br>如果还是想不通的话，把给定数组中的数按照从小到大排序后，就比较好理解了。比如将给定的数组数组排序[1,2,2,3,3,4,7,8]。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = Math.abs(nums[i])-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[index] &lt; <span class="number">0</span>)</span><br><span class="line">                res.add(Math.abs(index+<span class="number">1</span>));</span><br><span class="line">            nums[index] = -nums[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-数组中的重复数字"><a href="#1-2-数组中的重复数字" class="headerlink" title="1.2 数组中的重复数字"></a>1.2 数组中的重复数字</h2><center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/find%20all%20duplicates%20in%20an%20array_2.PNG"><br></center>

<ul>
<li>解法：这个题目就不能按照上面的解法来了，因为数组中的最小元素为0，最大元素为n-1，按照上述方法会产生越界问题。可以使用HashMap。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(numbers==<span class="keyword">null</span> || length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num: numbers)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(num))&#123;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            duplication[<span class="number">0</span>] = num;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(num, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-二维数组中的查找"><a href="#2-二维数组中的查找" class="headerlink" title="2. 二维数组中的查找"></a>2. 二维数组中的查找</h1><center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/find%20in%20a%20matrix.PNG"><br></center>

<ul>
<li>解法：从右上角开始查找。矩阵中的一个数，它左边的数都比它小，下边的数都比它大。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> rows = matrix.length, cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, c = cols - <span class="number">1</span>; <span class="comment">// 从右上角开始</span></span><br><span class="line">    <span class="keyword">while</span> (r &lt;= rows - <span class="number">1</span> &amp;&amp; c &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == matrix[r][c])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; matrix[r][c])</span><br><span class="line">            r++;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            c--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-替换空格"><a href="#3-替换空格" class="headerlink" title="3. 替换空格"></a>3. 替换空格</h1><center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/replace%20space.PNG"><br></center>

<ul>
<li>解法1：在字符串尾部填充任意字符，使得字符串的长度等于字符串替换之后的长度。因为一个空格要替换成三个字符（%20），因此当遍历到一个空格时，需要在尾部填充两个任意字符。<br>令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。</li>
</ul>
<p>从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldLen = str.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldLen; i++)</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) == <span class="string">' '</span>)</span><br><span class="line">            str.append(<span class="string">"  "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> P1 = oldLen - <span class="number">1</span>, P2 = str.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (P1 &gt;= <span class="number">0</span> &amp;&amp; P2 &gt; P1) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = str.charAt(P1--);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">' '</span>) &#123;</span><br><span class="line">            str.setCharAt(P2--, <span class="string">'0'</span>);</span><br><span class="line">            str.setCharAt(P2--, <span class="string">'2'</span>);</span><br><span class="line">            str.setCharAt(P2--, <span class="string">'%'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            str.setCharAt(P2--, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法2：利用Java自己的函数<code>replace(start, end, string)</code>函数帮助我们替换字符串。我们只需要找到空格的位置即可。注意该函数在替换时包含start不包含end。例子如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"1234"</span>);</span><br><span class="line">sb.replace(<span class="number">1</span>, <span class="number">3</span>, <span class="string">"nba"</span>);</span><br><span class="line">System.out.println(sb.toString());</span><br><span class="line"><span class="comment">//结果为:1nba4</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i) == <span class="string">' '</span>)&#123;</span><br><span class="line">            str.replace(i, i+<span class="number">1</span>, <span class="string">"%20"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-从尾到头打印链表"><a href="#4-从尾到头打印链表" class="headerlink" title="4. 从尾到头打印链表"></a>4. 从尾到头打印链表</h1><center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/print%20linkedlist.PNG"><br></center>

<ul>
<li><p>解法1：使用栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(listNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.add(listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            list.add(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法2：由于递归在本质上就是一个栈结构，所以理所当然想到递归。但是如果链表非常长，使用递归容易造成栈溢出，不是一个好方法。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(listNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.addAll(printListFromTailToHead(listNode.next));</span><br><span class="line">            list.add(listNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法3：由给定的链表逆序构建一个新的链表，则新链表的元素和给定链表的元素相反。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//逆序构建链表</span></span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(listNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode memo = listNode.next;</span><br><span class="line">            listNode.next = head.next;</span><br><span class="line">            head.next = listNode;</span><br><span class="line">            listNode = memo;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        head = head.next;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(head.val);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法4：使用<code>Collections.reverse()</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(listNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-重建二叉树"><a href="#5-重建二叉树" class="headerlink" title="5. 重建二叉树"></a>5. 重建二叉树</h1><center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/reBuildBinaryTree.PNG"><br></center>

<ul>
<li>解法1：使用递归。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; inOrderNumsIndex = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++)&#123;</span><br><span class="line">            inOrderNumsIndex.put(in[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reBuildBinaryTreeCore(pre, <span class="number">0</span>, pre.length-<span class="number">1</span>, <span class="number">0</span>, in.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">reBuildBinaryTreeCore</span><span class="params">(<span class="keyword">int</span> preorder[], <span class="keyword">int</span> preStartIndex, <span class="keyword">int</span> preEndIndex, <span class="keyword">int</span> inStartIndex, <span class="keyword">int</span> inEndIndex)</span></span>&#123;</span><br><span class="line">        <span class="comment">//这种情况下说明左子树已经排完，返回继续排右子树。</span></span><br><span class="line">        <span class="keyword">if</span>(preStartIndex &gt; preEndIndex)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preStartIndex]);</span><br><span class="line">        <span class="keyword">int</span> rootIndex = inOrderNumsIndex.get(root.val);</span><br><span class="line">        <span class="keyword">int</span> leftTreeSize = rootIndex - inStartIndex;</span><br><span class="line">        root.left = reBuildBinaryTreeCore(preorder, preStartIndex+<span class="number">1</span>, preStartIndex+leftTreeSize, inStartIndex, inStartIndex+leftTreeSize-<span class="number">1</span>);</span><br><span class="line">        root.right = reBuildBinaryTreeCore(preorder, preStartIndex+leftTreeSize+<span class="number">1</span>, preEndIndex, inStartIndex+leftTreeSize+<span class="number">1</span>, inEndIndex);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法2：和解法一的思想一样，只是更清楚一些。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//存放中序遍历的值和索引</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; inIndex = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.length &lt;= <span class="number">0</span> || in.length &lt;= <span class="number">0</span> || pre.length != in.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++)&#123;</span><br><span class="line">            inIndex.put(in[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = pre.length;</span><br><span class="line">        <span class="keyword">return</span> constructorCore(pre, in, <span class="number">0</span>, len-<span class="number">1</span>, <span class="number">0</span>, len-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">constructorCore</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in, <span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd)</span></span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[preStart]);</span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        root.right = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(preStart == preEnd)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inStart == inEnd &amp;&amp; pre[preStart] == in[inStart])&#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果输入错误，前序遍历和中序遍历结果不一致，则返回错误</span></span><br><span class="line">                System.out.println(<span class="string">"wrong input"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> index = inIndex.get(pre[preStart]);</span><br><span class="line">        <span class="comment">//int index = inIndex.get(root.val);</span></span><br><span class="line">        <span class="keyword">int</span> leftLen = index - inStart;</span><br><span class="line">        <span class="keyword">if</span>(leftLen &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            root.left = constructorCore(pre, in, preStart+<span class="number">1</span>, preStart+leftLen, inStart, index-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(inEnd - index &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            root.right = constructorCore(pre, in, preStart+leftLen+<span class="number">1</span>, preEnd, index+<span class="number">1</span>, inEnd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对解法2的理解：由于递归可以转换为栈，所以可以用栈来解释一下，画出如下的栈图。</p>
<center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/reBuildLeftBTree.jpg"><br></center>

<center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/reBuildRightBTree.jpg"><br></center>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%89%91%E6%8C%87%20offer%20%E9%A2%98%E8%A7%A3.md" target="_blank" rel="noopener">《剑指offer》题解</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/31/Hadoop单节点安装/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="adamhand">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dethnote">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/31/Hadoop单节点安装/" itemprop="url">Hadoop单节点安装</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-31T22:19:57+08:00">
                2018-12-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Hadoop/" itemprop="url" rel="index">
                    <span itemprop="name">Hadoop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="hadoop单节点安装"><a href="#hadoop单节点安装" class="headerlink" title="hadoop单节点安装"></a>hadoop单节点安装</h1><hr>
<h1 id="环境和版本"><a href="#环境和版本" class="headerlink" title="环境和版本"></a>环境和版本</h1><ul>
<li>ubuntu18.04</li>
<li>jdk1.8.0</li>
<li>hadoop2.9.2</li>
</ul>
<h1 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h1><p>略</p>
<h1 id="安装hadoop"><a href="#安装hadoop" class="headerlink" title="安装hadoop"></a>安装hadoop</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>选择在国内镜像下载，速度比较快。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirror.bit.edu.cn/apache/hadoop/common/stable/hadoop-2.9.2.tar.gz</span><br></pre></td></tr></table></figure></p>
<h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf hadoop-2.9.2.tar.gz</span><br></pre></td></tr></table></figure>
<p>进入<code>/etc/hadoop</code>目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/hadoop</span><br></pre></td></tr></table></figure></p>
<h2 id="修改hadooop-env-sh"><a href="#修改hadooop-env-sh" class="headerlink" title="修改hadooop-env.sh"></a>修改<code>hadooop-env.sh</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim hadoop-env.sh</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/opt/installed/jdk1.8.0_161/  # 注意这里要写绝对路径，不能写$&#123;JAVA_HOME&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配置core-site-xml"><a href="#配置core-site-xml" class="headerlink" title="配置core-site.xml"></a>配置core-site.xml</h2><p>fs.defaultFS ： 这个属性用来指定namenode的hdfs协议的文件系统通信地址，可以指定一个主机+端口，也可以指定为一个namenode服务（这个服务内部可以有多台namenode实现ha的namenode服务。</p>
<p>hadoop.tmp.dir : hadoop集群在工作的时候存储的一些临时文件的目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim core-site.xml</span><br></pre></td></tr></table></figure></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/hadoop/data/hadoopdata<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="配置hdfs-site-xml"><a href="#配置hdfs-site-xml" class="headerlink" title="配置hdfs-site.xml"></a>配置hdfs-site.xml</h2><p>dfs.namenode.name.dir：namenode数据的存放地点。也就是namenode元数据存放的地方，记录了hdfs系统中文件的元数据。</p>
<p>dfs.datanode.data.dir： datanode数据的存放地点。也就是block块存放的目录了。</p>
<p>dfs.replication：hdfs的副本数设置。也就是上传一个文件，其分割为block块后，每个block的冗余副本个数，默认配置是3。</p>
<p>dfs.secondary.http.address：secondarynamenode 运行节点的信息，和 namenode 不同节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim hdfs-silte.xml</span><br></pre></td></tr></table></figure></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/hadoop/data/hadoopdata/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>为了保证元数据的安全一般配置多个不同目录<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/hadoop/data/hadoopdata/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>datanode 的数据存储目录<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>HDFS 的数据块的副本存储个数, 默认是3<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    &lt;property&gt;</span></span><br><span class="line"><span class="comment">        &lt;name&gt;dfs.secondary.http.address&lt;/name&gt;</span></span><br><span class="line"><span class="comment">        &lt;value&gt;slave2:50090&lt;/value&gt;</span></span><br><span class="line"><span class="comment">        &lt;description&gt;secondarynamenode 运行节点的信息，和 namenode 不同节点&lt;/description&gt;</span></span><br><span class="line"><span class="comment">    &lt;/property&gt;  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="配置mapred-site-xml"><a href="#配置mapred-site-xml" class="headerlink" title="配置mapred-site.xml"></a>配置mapred-site.xml</h2><p>mapreduce.framework.name：指定mr框架为yarn方式，Hadoop二代MP也基于资源管理系统Yarn来运行 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim mapred-site.xml</span><br></pre></td></tr></table></figure></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="配置yarn-site-xml"><a href="#配置yarn-site-xml" class="headerlink" title="配置yarn-site.xml"></a>配置yarn-site.xml</h2><p>yarn.resourcemanager.hostname：yarn总管理器的IPC通讯地址</p>
<p>yarn.nodemanager.aux-services：YARN 集群为 MapReduce 程序提供的服务（常指定为 shuffle ）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim</span><br></pre></td></tr></table></figure></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Site specific YARN configuration properties --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;property&gt;</span></span><br><span class="line"><span class="comment">        &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;</span></span><br><span class="line"><span class="comment">        &lt;value&gt;slave3&lt;/value&gt;</span></span><br><span class="line"><span class="comment">    &lt;/property&gt;</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>YARN 集群为 MapReduce 程序提供的 shuffle 服务<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="配置hadoop环境变量"><a href="#配置hadoop环境变量" class="headerlink" title="配置hadoop环境变量"></a>配置hadoop环境变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># User specific aliases and functions</span><br><span class="line"> </span><br><span class="line">export HADOOP_HOME=/home/hadoop/apps/hadoop-2.9.1</span><br><span class="line"> </span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
<p>验证环境变量是否生效，查看hadoop版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop version</span><br></pre></td></tr></table></figure></p>
<h2 id="初始化hadoop-namenode节点"><a href="#初始化hadoop-namenode节点" class="headerlink" title="初始化hadoop namenode节点"></a>初始化hadoop namenode节点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs namenode -format</span><br></pre></td></tr></table></figure>
<p>成功后会有日志提示。</p>
<h2 id="启动hdfs"><a href="#启动hdfs" class="headerlink" title="启动hdfs"></a>启动hdfs</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start-dfs.sh</span><br></pre></td></tr></table></figure>
<p>然后输入root的密码。</p>
<hr>
<p>注意，如果启动的时候遇到<code>root@localhost&#39;s password:localhost:permission denied,please try again</code>问题，可能的原因有以下几个：</p>
<ul>
<li>root密码输入错误</li>
</ul>
<p>可以通过改密码的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo root</span><br></pre></td></tr></table></figure></p>
<p>然后输入两次新密码。</p>
<ul>
<li>防火墙的问题</li>
</ul>
<p>需要将防火墙关闭：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw enable</span><br></pre></td></tr></table></figure></p>
<p>可以通过<code>sudo ufw status</code>查看防火墙状态。</p>
<ul>
<li>root没有开启允许ssh的远程连接</li>
</ul>
<p>首先要确认ssh已经安装成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server  #open ssh</span><br></pre></td></tr></table></figure></p>
<p>辑配置文件，允许以 root 用户通过 ssh 登录：sudo vi /etc/ssh/sshd_config<br>找到：PermitRootLogin prohibit-password禁用(如果没有找到这一行，直接添加PermitRootLogin yes即可)<br>添加：PermitRootLogin yes<br>然后重启ssh服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service ssh restart</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/u010366748/article/details/82843454" target="_blank" rel="noopener">Hadoop学习（1）Hadoop2.9.1完全分布式环境搭建和测试</a><br><a href="https://blog.csdn.net/y12345678904/article/details/80743333" target="_blank" rel="noopener">ubuntu16.04安装伪分布式Hadoop2.9.1</a><br><a href="https://www.cnblogs.com/hmy-blog/p/6500909.html" target="_blank" rel="noopener">问题root@localhost’s password:localhost:permission denied,please try again</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/31/Linux下安装VSCode/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="adamhand">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dethnote">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/31/Linux下安装VSCode/" itemprop="url">Linux下安装VSCode</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-31T22:16:05+08:00">
                2018-12-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/工具/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="linux中安装VSCode"><a href="#linux中安装VSCode" class="headerlink" title="linux中安装VSCode"></a>linux中安装VSCode</h1><hr>
<h2 id="１-从官网下载"><a href="#１-从官网下载" class="headerlink" title="１.从官网下载"></a>１.从官网下载</h2><p>访问Visual Studio Code官网 <a href="https://code.visualstudio.com/docs?dv=linux64" target="_blank" rel="noopener">https://code.visualstudio.com/docs?dv=linux64</a><br>或者直接用下列命令下载64位安装包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://az764295.vo.msecnd.net/stable/7ba55c5860b152d999dda59393ca3ebeb1b5c85f/code-stable-code_1.7.2-1479766213_amd64.tar.gz</span><br></pre></td></tr></table></figure></p>
<h2 id="2-解压"><a href="#2-解压" class="headerlink" title="2.解压"></a>2.解压</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xzvf code-stable-code_1.7.2-1479766213_amd64.tar.gz</span><br></pre></td></tr></table></figure>
<h2 id="3-移动到local-usr下"><a href="#3-移动到local-usr下" class="headerlink" title="3.移动到local/usr下"></a>3.移动到local/usr下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv VSCode-linux-x64 /usr/local/</span><br></pre></td></tr></table></figure>
<h2 id="4-可能还需要给可执行的权限-然后就已经可以运行了"><a href="#4-可能还需要给可执行的权限-然后就已经可以运行了" class="headerlink" title="4.可能还需要给可执行的权限, 然后就已经可以运行了"></a>4.可能还需要给可执行的权限, 然后就已经可以运行了</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /usr/local/VSCode-linux-x64/code</span><br></pre></td></tr></table></figure>
<h2 id="5-复制一个VScode图标文件到-usr-share-icons-目录"><a href="#5-复制一个VScode图标文件到-usr-share-icons-目录" class="headerlink" title="5.复制一个VScode图标文件到 /usr/share/icons/ 目录"></a>5.复制一个VScode图标文件到 /usr/share/icons/ 目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/local/VSCode-linux-x64/resources/app/resources/linux/code.png /usr/share/icons/</span><br></pre></td></tr></table></figure>
<h2 id="6-创建启动器-在-usr-share-applications-目录-也可以将它复制到桌面目录"><a href="#6-创建启动器-在-usr-share-applications-目录-也可以将它复制到桌面目录" class="headerlink" title="6.创建启动器, 在/usr/share/applications/ 目录, 也可以将它复制到桌面目录"></a>6.创建启动器, 在/usr/share/applications/ 目录, 也可以将它复制到桌面目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/share/applications/VSCode.desktop</span><br></pre></td></tr></table></figure>
<p>输入下列文字;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Name=Visual Studio Code</span><br><span class="line">Comment=Multi-platform code editor for Linux</span><br><span class="line">Exec=/usr/local/VSCode-linux-x64/code</span><br><span class="line">Icon=/usr/share/icons/code.png</span><br><span class="line">Type=Application</span><br><span class="line">StartupNotify=true</span><br><span class="line">Categories=TextEditor;Development;Utility;</span><br><span class="line">MimeType=text/plain;</span><br></pre></td></tr></table></figure></p>
<p>保存后退出, 然后可以复制到桌面:<br>cp /usr/share/applications/VSCode.desktop ~/桌面/<br>之后 就会发现 桌面和 应用程序菜单都有了 VSCode的快捷方式了</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/31/RabbitMQ系列-1-初识消息中间件/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="adamhand">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dethnote">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/31/RabbitMQ系列-1-初识消息中间件/" itemprop="url">RabbitMQ系列(1)--初识消息中间件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-31T22:10:22+08:00">
                2018-12-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/RabbitMQ/" itemprop="url" rel="index">
                    <span itemprop="name">RabbitMQ</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="RabbitMQ系列-1-–认识消息队列中间件"><a href="#RabbitMQ系列-1-–认识消息队列中间件" class="headerlink" title="RabbitMQ系列(1)–认识消息队列中间件"></a>RabbitMQ系列(1)–认识消息队列中间件</h1><hr>
<h1 id="初识消息队列中间件"><a href="#初识消息队列中间件" class="headerlink" title="初识消息队列中间件"></a>初识消息队列中间件</h1><p>消息(Message)是指在应用之间传递的数据。</p>
<p>消息队列中间件(Message Queue Middleware，MQ)是一种“中间件”，这个“中间”有两层含义：一种是<strong>上下层之间的中间(纵向的“中间”)</strong>，一种是<strong>左右之间的中间（横向的“中间”）</strong>。</p>
<p>上下层之间的中间是指，消息中间件被夹在“应用层”和“传输层”之间，它对传输层的协议进行了封装，为上层应用程序提供跨平台的数据交流。</p>
<p>左右之间的中间是指，消息中间件常常被用于分布式环境中，它可以为两个分布式节点之间提供通信服务。</p>
<h1 id="传递模式"><a href="#传递模式" class="headerlink" title="传递模式"></a>传递模式</h1><p>消息中间件一般有两种传递模式：<strong>点对点</strong>(P2P，Point to point)模式和<strong>发布/订阅</strong>(Pub/Sub)模式。</p>
<h2 id="点对点模式"><a href="#点对点模式" class="headerlink" title="点对点模式"></a>点对点模式</h2><p>点对点模式是基于队列(queue)的，消息生产者生产消息发送到queue中，然后消息消费者从queue中取出并且消费消息。队列的存在使得消息的异步传输成为可能。消息被消费以后，queue中不再存储，所以消息消费者不可能消费到已经被消费的消息。</p>
<p>Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。</p>
<p>示意图如下图所示：</p>
<center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/mq-p2p.jpg"><br></center>

<h2 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h2><p>Pub/Sub发布订阅（广播）：使用topic作为通信载体。消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到topic的消息会被所有订阅者消费。</p>
<p>示意图如下：</p>
<center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/mq-pub-sub.jpg"><br></center>

<h1 id="常用协议"><a href="#常用协议" class="headerlink" title="常用协议"></a>常用协议</h1><h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><p>AMQP即<strong>Advanced Message Queuing Protocol(高级队列消息协议)</strong>。AMQP协议定义了消息路由规则和方式。生产者将消息发送到Broker，Broker中的Exchange充当了路由器的角色，由它将消息路由到一个或者多个队列中。如果路由不到，或许会返回给生产者，获取会丢弃。</p>
<p>多个消费者可以订阅同一个队列中的消息，这是队列中的消息会通过“轮询”的方式平均分配给每个消费者，而不是每个消费者都会消费所有消息。</p>
<p>AMQP的模型如下所示：</p>
<center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/amqp.jpg"><br></center>

<h2 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h2><p>Java消息服务（Java Message Service，JMS）应用程序接口是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。点对点与发布订阅最初是由JMS定义的。</p>
<p>严格来说，JMS不是一种消息队列协议，它是一种跨平台的API，换句话说，可以使用JMS API来连接支持AMQP、STOMP等协议的消息中间件产品，它的作用更像JDBC，我们可以使用JDBC API来连接具体的数据库产品。</p>
<h1 id="常见消息中间件对比"><a href="#常见消息中间件对比" class="headerlink" title="常见消息中间件对比"></a>常见消息中间件对比</h1><p>待续。</p>
<hr>
<h1 id="补丁：消息的消费模式"><a href="#补丁：消息的消费模式" class="headerlink" title="补丁：消息的消费模式"></a>补丁：消息的消费模式</h1><p>消息的消费模式有两种：<strong>推模式(push)</strong>和<strong>拉模式(pull)</strong>。</p>
<p><strong>推(push)模式</strong>是一种基于客户器/服务器机制、由服务器主动将信息送到客户器的技术。在push模式应用中，服务器把信息送给客户器之前，并没有明显的客户请求。push事务由服务器发起。push模式可以让信息主动、快速地寻找用户/客户器，信息的主动性和实时性比较好。但精确性较差，可能推送的信息并不一定满足客户的需求。推送模式不能保证能把信息送到客户器，因为推模式采用了广播机制，如果客户器正好联网并且和服务器在同一个频道上，推送模式才是有效的。push模式无法跟踪状态，采用了开环控制模式，没有用户反馈信息。在实际应用中，由客户器向服务器发送一个申请，并把自己的地址（如IP、port）告知服务器，然后服务器就源源不断地把信息推送到指定地址。在多媒体信息广播中也采用了推模式。另外，如手机*、qq广播。</p>
<p><strong>拉（pull）模式</strong>与推模式相反，是由客户器主动发起的事务。服务器把自己所拥有的信息放在指定地址（如IP、port），客户器向指定地址发送请求，把自己需要的资源“拉”回来。不仅可以准确获取自己需要的资源，还可以及时把客户端的状态反馈给服务器。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《RabbitMQ实战指南》<br>《分布式消息中间件实战》<br><a href="https://blog.csdn.net/lizhitao/article/details/47723105" target="_blank" rel="noopener">消息队列中点对点与发布订阅区别</a><br><a href="https://blog.csdn.net/wqc19920906/article/details/82193316" target="_blank" rel="noopener">消息中间件（一）MQ详解及四大MQ比较</a><br><a href="https://blog.csdn.net/btt2013/article/details/80211599" target="_blank" rel="noopener">Java消息中间件(入门篇)</a><br><a href="https://blog.csdn.net/zeng_z/article/details/77246368" target="_blank" rel="noopener">消息模式–推模式和拉模式</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/31/Java并发-3-从synchronized到锁优化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="adamhand">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dethnote">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/31/Java并发-3-从synchronized到锁优化/" itemprop="url">Java并发(3)--从synchronized到锁优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-31T17:08:41+08:00">
                2018-12-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java并发——从synchronized到锁优化"><a href="#Java并发——从synchronized到锁优化" class="headerlink" title="Java并发——从synchronized到锁优化"></a>Java并发——从synchronized到锁优化</h1><hr>
<h1 id="synchronized用法"><a href="#synchronized用法" class="headerlink" title="synchronized用法"></a>synchronized用法</h1><p>synchronized关键字同步的三种用法:<br>①.同步实例方法，锁是当前实例对象<br>②.同步类方法，锁是当前类对象<br>③.同步代码块，锁是括号里面的对象</p>
<p>示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步实例方法，锁实例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步类方法，锁类对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步代码块</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 锁类对象</span></span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedTest.class) &#123;</span><br><span class="line">            <span class="comment">// 锁实例对象</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="synchronized实现"><a href="#synchronized实现" class="headerlink" title="synchronized实现"></a>synchronized实现</h1><p>javap -verbose查看上述示例:</p>
<center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/synchronized_javap.PNG"><br></center>

<p>可以看到，同步代码块是使用monitorenter和monitorexit指令实现的，同步方法（在这看不出来需要看JVM底层实现）依靠的是方法修饰符上的ACC_SYNCHRONIZED实现。具体如下：</p>
<p><strong>同步方法：</strong>方法级同步没有通过字节码指令来控制，它实现在方法调用和返回操作之中。当方法调用时，调用指令会检查方法ACC_SYNCHRONIZED访问标志是否被设置，若设置了则执行线程需要持有管程(Monitor)才能运行方法，当方法完成(无论是否出现异常)时释放管程。<br><strong>同步代码块</strong>：synchronized关键字经过编译后，会在同步块的前后分别形成monitorenter和monitorexit两个字节码指令，每条monitorenter指令都必须执行其对应的monitorexit指令，为了保证方法异常完成时这两条指令依然能正确执行，编译器会<strong>自动产生一个异常处理器</strong>，其目的就是用来执行monitorexit指令(图中14-18、24-30为异常流程)。</p>
<h1 id="java对象头和monitor"><a href="#java对象头和monitor" class="headerlink" title="java对象头和monitor"></a>java对象头和monitor</h1><p>Java对象头和monitor是实现synchronized的基础。</p>
<h2 id="java对象头"><a href="#java对象头" class="headerlink" title="java对象头"></a>java对象头</h2><p>synchronized用的锁是存在Java对象头里的，Hotspot虚拟机的对象头主要包括两部分数据：<strong>Mark Word（标记字段）</strong>、<strong>Klass Pointer（类型指针）</strong>。其中Klass Point是是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，Mark Word用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键。</p>
<h3 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h3><p>默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p>
<h3 id="Klass-Point"><a href="#Klass-Point" class="headerlink" title="Klass Point"></a>Klass Point</h3><p>对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h2><p>每个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取该对象的监视器才能进入同步块和同步方法，如果没有获取到监视器的线程将会被阻塞在同步块和同步方法的入口处，进入到BLOCKED状态，如图:</p>
<center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/monitorenterandexit.jpg"><br></center>

<p>Monitor是<strong>线程私有</strong>的数据结构，每个线程都有一个可用<strong>monitor record</strong>列表，同时<br>还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor record关联(对象头的MarkWord中的LockWord指向monitor record的起始地址)，同时monitor record中有一个owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。其结构如下:</p>
<center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/monitorstructure.jpg"><br></center>

<ul>
<li><strong>Owner：</strong>初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；</li>
<li><strong>EntryQ:</strong>关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程。</li>
<li><strong>RcThis:</strong>表示blocked或waiting在该monitor record上的所有线程的个数。</li>
<li><strong>Nest:</strong>用来实现重入锁的计数。</li>
<li><strong>HashCode:</strong>保存从对象头拷贝过来的HashCode值（可能还包含GC age）。</li>
<li><strong>Candidate:</strong>用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁。</li>
</ul>
<h1 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h1><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p>
<p>所以目前锁一共有<strong>4种</strong>状态，级别从低到高依次是：<strong>无锁</strong>、<strong>偏向锁</strong>、<strong>轻量级锁</strong>和<strong>重量级锁</strong>。锁状态只能升级不能降级。</p>
<p>四种锁状态对应的的Mark Word内容如下：</p>
<table>
<thead>
<tr>
<th>锁状态</th>
<th>存储内容</th>
<th>标志位</th>
</tr>
</thead>
<tbody>
<tr>
<td>无锁</td>
<td>对象的hashCode、对象分代年龄、是否是偏向锁（0）</td>
<td>01</td>
</tr>
<tr>
<td>偏向锁</td>
<td>偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td>
<td>01</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>指向栈中锁记录的指针</td>
<td>00</td>
</tr>
<tr>
<td>重量级锁</td>
<td>指向互斥量（重量级锁）的指针</td>
<td>10</td>
</tr>
</tbody>
</table>
<h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p>
<p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。CAS即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p>
<p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p>
<p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p>
<p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p>
<p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p>
<p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p>
<p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p>
<p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p>
<p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p>
<p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p>
<h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p>
<p>重量级锁通过对象内部的监视器(monitor)实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>偏向锁通过对比Mark Word解决加锁问题，避免多次执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://juejin.im/post/5b42c2546fb9a04f8751eabc" target="_blank" rel="noopener">Java并发——关键字synchronized解析</a><br><a href="http://cmsblogs.com/?p=2071" target="_blank" rel="noopener">【死磕Java并发】—–深入分析synchronized的实现原理</a><br><a href="https://blog.csdn.net/u012465296/article/details/53022317" target="_blank" rel="noopener">Java中synchronized的实现原理与应用</a><br><a href="https://www.jianshu.com/p/c5058b6fe8e5" target="_blank" rel="noopener">JVM源码分析之synchronized实现</a><br><a href="https://www.jianshu.com/p/9c19eb0ea4d8" target="_blank" rel="noopener">JVM源码分析之java对象头实现</a><br><a href="https://tech.meituan.com/Java_Lock.html" target="_blank" rel="noopener">不可不说的Java“锁”事</a><br><a href="https://blog.csdn.net/jingzi123456789/article/details/69951057" target="_blank" rel="noopener">JAVA并发：多线程编程之同步“监视器monitor”（三）</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/31/欲/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="adamhand">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dethnote">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/31/欲/" itemprop="url">欲</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-31T17:04:06+08:00">
                2018-12-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/诗/" itemprop="url" rel="index">
                    <span itemprop="name">诗</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>欲</strong></p>
<p>梧桐树<br>光影辉煌<br>小路蜿蜒<br>阴影<br>明亮<br>斑驳<br>凉风飒飒<br>路灯的光被吹散</p>
<p>身影摇曳<br>丰满<br>脚步缓缓<br>低头<br>思索<br>手放胸前<br>卷发<br>遮住侧脸</p>
<p>快步超过去<br>回头<br>偷看一眼<br>肉肉的脸<br>还有胳膊<br>和手<br>如果维纳斯穿上衣服<br>应该就是这般<br>这一想法掠过<br>我感到一阵罪恶感</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/31/Netty系列-3-Netty传输/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="adamhand">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dethnote">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/31/Netty系列-3-Netty传输/" itemprop="url">Netty系列(3)--Netty传输</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-31T16:59:59+08:00">
                2018-12-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Netty/" itemprop="url" rel="index">
                    <span itemprop="name">Netty</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Netty系列-3-–netty传输"><a href="#Netty系列-3-–netty传输" class="headerlink" title="Netty系列(3)–netty传输"></a>Netty系列(3)–netty传输</h1><hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据在网络中是以<strong>字节</strong>的形式传输的，这些字节如何流动取决于网络传输–一个将底层数据传输机制进行抽象的概念。</p>
<p>Netty提供了诸多的传输方式，而且提供了通用API供用户调用。</p>
<h1 id="Netty传输API"><a href="#Netty传输API" class="headerlink" title="Netty传输API"></a>Netty传输API</h1><p>传输API的核心是interfaceChannel，它被用于所有的I/O操作。Channel类的层次结构如图所示：</p>
<center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/netty-transport.PNG"><br></center>

<p>如图所示，每个Channel都将被分配一个ChannelPipeline和ChannelConfig。ChannelConfig包含了该Channel的所有配置设置，并且支持热更新。</p>
<p>ChannelPipeline持有所有将应用于入站和出站数据以及事件的ChannelHandler实例，这些ChannelHandler实现了应用程序用于处理状态变化以及数据处理的逻辑。</p>
<p>ChannelHandler的典型用途包括：</p>
<ul>
<li>将数据从一种格式转为另外一种格式</li>
<li>提供异常通知</li>
<li>提供Channel变为活动或非活动的通知</li>
<li>提供当Channel注册到EventLoop或者从EventLoop注销时通知</li>
<li>提供有关用户自定义事件的通知</li>
</ul>
<p>Netty 所提供的广泛功能只依赖于少量的接口。这意味着，可以对应用程序逻辑进行重大的修改，而无需大规模的重构代码库。</p>
<h1 id="Netty内置的传输"><a href="#Netty内置的传输" class="headerlink" title="Netty内置的传输"></a>Netty内置的传输</h1><p>Netty能够提供的传输包含以下几个：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>NIO</td>
<td>使用Java.nio.channels包作为基础—————基于选择器的方式</td>
<td>非阻塞代码库或一个常规的起点</td>
</tr>
<tr>
<td>Epoll</td>
<td>由JNI驱动的epoll()和非阻塞IO。这个传输支持只有在Linux上可用的多种特性。如SO_Reuseport，比NIO传输更快且完全非阻塞的</td>
<td>非阻塞代码库或一个常规的起点(在Linux上)</td>
</tr>
<tr>
<td>OIO</td>
<td>使用java.net包作为基础—————使用阻塞流</td>
<td>阻塞代码库</td>
</tr>
<tr>
<td>Local</td>
<td>可以在VM内部通过管道进行通信的文本传输</td>
<td>同一个JVM内部通信</td>
</tr>
<tr>
<td>Embedded</td>
<td>Embedded传输，允许使用ChannelHandler而又不需要真正的基于网络的传输。这在测试ChannelHandler时很有用</td>
<td>测试ChannelHandler</td>
</tr>
</tbody>
</table>
<h2 id="NIO–非阻塞I-O"><a href="#NIO–非阻塞I-O" class="headerlink" title="NIO–非阻塞I/O"></a>NIO–非阻塞I/O</h2><p>NIO的使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup goup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">new</span> ServerBootstrap().channel(NioServerSockerChannel.class) <span class="comment">//服务端</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Bootstrap().channel(NioSockerChannel.class) <span class="comment">//客户端</span></span><br></pre></td></tr></table></figure></p>
<p>NIO提供了一个所有I/O操作的全异步实现。选择器背后的概念相当于一个“注册表”，在那里你可以请求在Channel的状态发生变化时得到通知。可能的状态有：</p>
<ul>
<li>新的Channel已被接受并且就绪</li>
<li>Channel连接已经完成</li>
<li>Channel有已经就绪的可供读取的数据</li>
<li>Channel可用于写数据</li>
</ul>
<p>状态变化集的定义如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>OP_ACCEPT</td>
<td>请求在接受新连接并创建Channel时获得通知</td>
</tr>
<tr>
<td>OP_CONNECT</td>
<td>请求在建立一个连接时获得通知</td>
</tr>
<tr>
<td>OP_READ</td>
<td>请求当数据已就绪 ，可以在Channel中读取数据时获得通知</td>
</tr>
<tr>
<td>OP_WRITE</td>
<td>请求当可以向Channel中写更多数据时获得通知。这处理了套接字缓冲区被完全填满时的情况，该情况通知发生在数据的发送速度比远程节点可处理的速度更快时</td>
</tr>
</tbody>
</table>
<p>选择并处理状态变化集的过程如下：</p>
<center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/netty-selector.PNG"><br></center>

<h2 id="Epoll————用于LINUX的本地非阻塞传输"><a href="#Epoll————用于LINUX的本地非阻塞传输" class="headerlink" title="Epoll————用于LINUX的本地非阻塞传输"></a>Epoll————用于LINUX的本地非阻塞传输</h2><p>Netty为Linux提供了一组NIO API，其以一种和它本身的设计更加一致的方法使用epoll，并且以一种更加轻量的方式使用中断。如果应用程序指在运行于linux系统，应首先利用这个传输；在高负载下它的性能要优于JDK的NIO实现。</p>
<p>epoll的使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">EventLoopGroup group = <span class="keyword">new</span> EpollEventLoopGroup();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">new</span> ServerBootstrap().channel(EpollServerSocketChannel.class) <span class="comment">//服务端</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Bootstrap().channel(EpollSocketChannel.class) <span class="comment">//客户端</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h2 id="OIO–旧的阻塞I-O"><a href="#OIO–旧的阻塞I-O" class="headerlink" title="OIO–旧的阻塞I/O"></a>OIO–旧的阻塞I/O</h2><p>Netty是如何能够使用和用于异步传输相同的API来支持OIO的呢？</p>
<p>在NIO中，一个 EventLoop 对应一个线程，一个Channel 绑定一个 EventLoop，而一个EventLoop 可以绑定多个Channel 来实现异步，也就是说一个线程可以处理多个 Channel。而OIO中，一个 EventLoop 仅绑定一个 Channel，也就是说每个线程只处理一个Channel ，这就有点像传统IO中，在服务端（ServerSocket）写了一个多线程来处理客户端的并发请求。</p>
<p>现在还有一个问题，channel是双向的，既可以读，也可以写。而stream是单向的，OIO中利用 InputStream 来读，OutputStream 来写。那么Channel 是如何实现阻塞的读和写的呢？答案就是， Netty利用了<strong>SO_TIMEOUT</strong>这个Socket标志，<strong>它指定了等待一个I/O操作完成的最大毫秒数,I/O 操作期间Channel是阻塞的，如果操作在指定的时间间隔内没有完成，则将会抛出一个SocketTimeout Exception。 Netty将捕获这个异常并继续处理循环。在EventLoop下一次运行时，它将再次尝试。</strong>这实际上也是类似于Netty这样的异步框架能够支持OIO的唯一方式。</p>
<p>OIO的使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">EventLoopGroup group = <span class="keyword">new</span> OioEventLoopGroup();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">new</span> ServerBootstrap().channel(OioServerSocketChannel.class)  <span class="comment">//服务端</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Bootstrap().channel(OioSocketChannel.class)  <span class="comment">//客户端</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>OIO的处理逻辑如下图所示：</p>
<center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/netty-oio.PNG"><br></center>

<p>##Local —— 用于 JVM 内部通信的 Local 传输<br>Netty 提供了一个Local传输， 用于在同一个 JVM 中运行的客户端和服务器程序之间的异步通信。</p>
<p> 在这个传输中，和服务器 Channel 相关联的 SocketAddress 并没有绑定物理网络地址；相反，只要服务器还在运行， 它就会被存储在注册表里，并在 Channel 关闭时注销。 因为这个传输并不接受真正的网络流量，所以它并不能够和其他传输实现进行互操作。因此，客户端希望连接到（在同一个 JVM 中）使用了这个传输的服务器端时也必须使用它。</p>
<p>Local的使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">EventLoopGroup group = <span class="keyword">new</span> DefaultEventLoop();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">new</span> ServerBootstrap().channel(LocalServerChannel.class) <span class="comment">//服务端</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Bootstrap().channel(LocalChannel.class) <span class="comment">//客户端</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h2 id="Embedded"><a href="#Embedded" class="headerlink" title="Embedded"></a>Embedded</h2><p>Netty 提供了一种额外的传输， 使得你可以将一组 ChannelHandler 作为帮助器类嵌入到其他的 ChannelHandler 内部。 通过这种方式，你将可以扩展一个 ChannelHandler 的功能，而又不需要修改其内部代码。</p>
<p>Embedded 传输的关键是一个被称为 EmbeddedChannel 的具体的Channel实现。</p>
<p>如果你想要为自己的 ChannelHandler 实现编写单元测试， 那么请考虑使用 Embedded 传输。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Netty 实战》</p>
<p><a href="https://www.jianshu.com/p/9581068f9739" target="_blank" rel="noopener">《Netty实战》–传输</a></p>
<p><a href="https://www.cnblogs.com/jmcui/p/9171733.html" target="_blank" rel="noopener">Netty 系列二（传输）.</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">adamhand</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index-1.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">adamhand</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
