<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Dethnote">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Dethnote">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dethnote">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>Dethnote</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dethnote</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/Java-I-O-3-对象操作/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="adamhand">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dethnote">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/Java-I-O-3-对象操作/" itemprop="url">Java I/O(3)--对象操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T21:54:11+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="四、对象操作"><a href="#四、对象操作" class="headerlink" title="四、对象操作"></a>四、对象操作</h1><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>序列化就是将一个对象转换成字节序列，方便存储和传输。</p>
<blockquote>
<ul>
<li>序列化：ObjectOutputStream.writeObject()</li>
<li>反序列化：ObjectInputStream.readObject()</li>
</ul>
</blockquote>
<p>不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。</p>
<h2 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h2><p>序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    A a1 = <span class="keyword">new</span> A(<span class="number">123</span>, <span class="string">"abc"</span>);</span><br><span class="line">    String objectFile = <span class="string">"file/a1"</span>;</span><br><span class="line"></span><br><span class="line">    ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(objectFile));</span><br><span class="line">    objectOutputStream.writeObject(a1);</span><br><span class="line">    objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">    ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(objectFile));</span><br><span class="line">    A a2 = (A) objectInputStream.readObject();</span><br><span class="line">    objectInputStream.close();</span><br><span class="line">    System.out.println(a2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> String y;</span><br><span class="line"></span><br><span class="line">    A(<span class="keyword">int</span> x, String y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"x = "</span> + x + <span class="string">"  "</span> + <span class="string">"y = "</span> + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h2><p>transient 关键字可以使一些属性不会被序列化。</p>
<p>ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/Java-I-O-2-File/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="adamhand">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dethnote">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/Java-I-O-2-File/" itemprop="url">Java I/O(2)--File</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T21:52:37+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="三、磁盘操作——File"><a href="#三、磁盘操作——File" class="headerlink" title="三、磁盘操作——File"></a>三、磁盘操作——File</h1><p>File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="文件或文件夹的创建"><a href="#文件或文件夹的创建" class="headerlink" title="文件或文件夹的创建"></a>文件或文件夹的创建</h3><p>主要涉及到三个方法：</p>
<blockquote>
<ul>
<li>createNewFile()：创建文件，这句话后，才真正在磁盘上创建了文件。</li>
<li>mkdir()：//创建目录，如果新建的目录的上级目录不存在会报异常不能成功创建文件夹。</li>
<li>mkdirs()：//创建目录，如果新建的目录的上级目录不存在则会将目录与上级目录一起创建。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="comment">//创建了file对象并不是创建了真实的文件，执行这句话后，如果文件不存在，并没有创建</span></span><br><span class="line">	File file = <span class="keyword">new</span> File(<span class="string">"/usr/Prom/eclipse/testAll/src/FileTest/createFile.txt"</span>);</span><br><span class="line">	File dir = <span class="keyword">new</span> File(<span class="string">"/usr/Prom/eclipse/testAll/src/FileTest/dir"</span>);</span><br><span class="line">	File dir_1 = <span class="keyword">new</span> File(<span class="string">"/usr/Prom/eclipse/testAll/src/FileTest/dir_1/a.txt"</span>);</span><br><span class="line">	<span class="keyword">if</span>(!file.exists())</span><br><span class="line">		file.createNewFile();  <span class="comment">//创建文件，这句话后，才真正在磁盘上创建了文件</span></span><br><span class="line">	<span class="keyword">if</span>(!dir.exists())</span><br><span class="line">		dir.mkdir();          <span class="comment">//创建目录，如果新建的目录的上级目录不存在会报异常不能成功创建文件夹</span></span><br><span class="line">	<span class="keyword">if</span>(!dir_1.exists())</span><br><span class="line">		dir_1.mkdirs();       <span class="comment">//创建目录，如果新建的目录的上级目录不存在则会将目录与上级目录一起创建。  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断文件或文件夹属性"><a href="#判断文件或文件夹属性" class="headerlink" title="判断文件或文件夹属性"></a>判断文件或文件夹属性</h3><p>isFile()和isDirectory()分别用于判断是不是文件和是不是文件夹，canRead(),canWrite(),isHidden(),分别用于判断文件是否可读，可写，是否隐藏。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">judgeFile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">	file.setReadable(<span class="keyword">true</span>);     <span class="comment">//设置文件可读</span></span><br><span class="line">	file.setWritable(<span class="keyword">false</span>);    <span class="comment">//设置文件不可写</span></span><br><span class="line">	System.out.println(file.isFile());   <span class="comment">//判断是不是文件</span></span><br><span class="line">	System.out.println(file.isDirectory()); <span class="comment">//判断是不是路径</span></span><br><span class="line">	System.out.println(file.isHidden());  <span class="comment">//判断是不是隐藏文件</span></span><br><span class="line">	System.out.println(file.canRead());  <span class="comment">//判断是不是可读</span></span><br><span class="line">	System.out.println(file.canWrite()); <span class="comment">//判断是不是可写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="文件或文件夹的删除"><a href="#文件或文件夹的删除" class="headerlink" title="文件或文件夹的删除"></a>文件或文件夹的删除</h3><p>删除一个文件比较简单，直接判断文件是否存在，如果存在的话就删除，如果文件不存在可以不用操作。但是删除一个文件夹比较麻烦，我们不能够直接的删除一个文件夹，删除文件夹时必须保证该文件夹为空，也就是说文件夹里面的文件和文件夹要全部被删除之后才能够删除该文件夹。</p>
<p>递归删除一个文件或路径<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除文件或路径，参数为File</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeFiles</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">	File[] files = file.listFiles();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(File f : files) &#123;</span><br><span class="line">		<span class="keyword">if</span>(f.isDirectory())</span><br><span class="line">			removeFiles(f);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			System.out.println(f+<span class="string">":"</span>+f.delete());</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(file+<span class="string">":"</span>+file.delete());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除文件或路径，参数为路径的字符串表示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dir</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteFiles</span><span class="params">(String dir)</span> </span>&#123;</span><br><span class="line">	File file = <span class="keyword">new</span> File(dir);</span><br><span class="line">	<span class="keyword">if</span>(!file.exists())</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(file.isFile())</span><br><span class="line">		System.out.println(file+<span class="string">":"</span>+file.delete());</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(file.isDirectory()) &#123;</span><br><span class="line">		File[] files = file.listFiles();</span><br><span class="line">		<span class="keyword">for</span>(File f : files) &#123;</span><br><span class="line">			System.out.print(<span class="string">":"</span>+f.getAbsolutePath());</span><br><span class="line">			deleteFiles(f.getAbsolutePath());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(file+<span class="string">":"</span>+file.delete());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="和流的联合使用"><a href="#和流的联合使用" class="headerlink" title="和流的联合使用"></a>和流的联合使用</h3><p>将一个文件中的内容复制到另一个文件中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String fromPath = <span class="string">"/usr/Prom/eclipse/testAll/src/IO/from.txt"</span>;</span><br><span class="line">        String toPath = <span class="string">"/usr/Prom/eclipse/testAll/src/IO/to.txt"</span>;</span><br><span class="line"></span><br><span class="line">        readWriteDemo(fromPath, toPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readWriteDemo</span><span class="params">(String fromPath, String toPath)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        File fileFrom = <span class="keyword">new</span> File(fromPath);</span><br><span class="line">        File fileTo = <span class="keyword">new</span> File(toPath);</span><br><span class="line">        <span class="keyword">if</span>(!fileFrom.exists())</span><br><span class="line">        	fileFrom.createNewFile();</span><br><span class="line">        <span class="keyword">if</span>(!fileTo.exists())</span><br><span class="line">        	fileTo.createNewFile();</span><br><span class="line">    	</span><br><span class="line">    	FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">        FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fr = <span class="keyword">new</span> FileReader(fileFrom);</span><br><span class="line">            fw = <span class="keyword">new</span> FileWriter(fileTo);</span><br><span class="line">            <span class="comment">//注意和FileInputStream不同的是，这里读取的是字符，所以要新建字符数组做缓冲区。</span></span><br><span class="line">            <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((len = fr.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                fw.write(buf, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fr != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fr.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fw != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="文件过滤器"><a href="#文件过滤器" class="headerlink" title="文件过滤器"></a>文件过滤器</h2><p>在java中,专门提供了文件过滤器接口.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> interface FilenameFilter　　　　<span class="title">accept</span><span class="params">(File dirs,String name)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> interface FileFilter　　　　　　　<span class="title">accept</span><span class="params">(File pathname)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>下面看具体的应用。</p>
<p>需要注意list方法和listFiles方法的两点区别：</p>
<blockquote>
<ul>
<li>返回值类型不同：前者为String数组，后者为File对象数组 </li>
<li>数组中元素内容不同：前者为string类型的【文件名】（包含后缀名），后者为File对象类型的【完整路径】。<br>因此，遍历文件夹中所有文件，包括子文件夹中的文件时，必须用listFiles（）方法</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后缀名过滤</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileFilterDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	File dir = <span class="keyword">new</span> File(<span class="string">"/usr/Prom/eclipse/testAll/src/FileFilter/11"</span>);</span><br><span class="line">	<span class="keyword">if</span>(!dir.exists())</span><br><span class="line">		dir.mkdirs();</span><br><span class="line">	<span class="comment">//list方法的参数不能为FileFlter</span></span><br><span class="line">	File[] fileList = dir.listFiles(<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> !pathname.isHidden();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(File f : fileList) &#123;</span><br><span class="line">		System.out.println(f);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 隐藏文件过滤</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileNameFilterDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	File dir = <span class="keyword">new</span> File(<span class="string">"/usr/Prom/eclipse/testAll/src/FileFilter/11"</span>);</span><br><span class="line">	<span class="keyword">if</span>(!dir.exists())</span><br><span class="line">		dir.mkdirs();</span><br><span class="line">	<span class="comment">//使用listFiles方法也行</span></span><br><span class="line">	String[] fileList = dir.list(<span class="keyword">new</span> FilenameFilter() &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> name.endsWith(<span class="string">".java"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(String f : fileList) &#123;</span><br><span class="line">		System.out.println(f);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="File和Properties"><a href="#File和Properties" class="headerlink" title="File和Properties"></a>File和Properties</h2><p>Properties继承自Hashtable，属于Map体系，主要用于生产配置文件与读取配置文件的信息。它可以和IO流结合，从流中读取配置文件的信息加载到Properties对象中，在对象中完成对配置文件中信息的修改后再通过流将信息写入到文件中，相当于是一个中间的操作过程。Properties中的键和值都是字符串类型。</p>
<p>看一下具体的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	String filePath = <span class="string">"/usr/Prom/eclipse/testAll/src/FileFilter/test.properties"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建File对象，配置文件的后缀名一般也叫properties</span></span><br><span class="line">	File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">	<span class="keyword">if</span>(!file.exists())</span><br><span class="line">		file.createNewFile();</span><br><span class="line">	</span><br><span class="line">	creatProperties(file);</span><br><span class="line">	</span><br><span class="line">	readProperties(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取配置文件的信息 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readProperties</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!file.exists())</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建Properties对象</span></span><br><span class="line">	Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">	<span class="comment">//加载配置文件信息到Properties中</span></span><br><span class="line">	properties.load(<span class="keyword">new</span> FileReader(file));</span><br><span class="line">	<span class="comment">//遍历</span></span><br><span class="line">	Set&lt;Entry&lt;Object, Object&gt;&gt; entrys = properties.entrySet();</span><br><span class="line">	<span class="keyword">for</span>(Entry&lt;Object, Object&gt; entry  :entrys)&#123;</span><br><span class="line">		System.out.println(<span class="string">"键："</span>+ entry.getKey() +<span class="string">" 值："</span>+ entry.getValue());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//修改狗娃的密码</span></span><br><span class="line">	properties.setProperty(<span class="string">"狗娃"</span>, <span class="string">"007"</span>);</span><br><span class="line">	<span class="comment">//把修改后的Properties写回配置文件</span></span><br><span class="line">	properties.store(<span class="keyword">new</span> FileWriter(file), <span class="string">"info"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存配置文件文件的信息。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">creatProperties</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!file.exists())</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建Properties</span></span><br><span class="line">	Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">	properties.setProperty(<span class="string">"狗娃"</span>, <span class="string">"123"</span>);</span><br><span class="line">	properties.setProperty(<span class="string">"狗剩"</span>,<span class="string">"234"</span>);</span><br><span class="line">	properties.setProperty(<span class="string">"铁蛋"</span>,<span class="string">"345"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一个参数是一个输出流对象，第二参数是使用一个字符串描述这个配置文件的信息。</span></span><br><span class="line">	properties.store(<span class="keyword">new</span> FileWriter(file), <span class="string">"info"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一个例子：定义功能，获取一个应用程序运行的次数，如果超过3次，给出使用次数已到请注册的提示。并不要在运行<br>程序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetCounts</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		String filePath = <span class="string">"/usr/Prom/eclipse/testAll/src/FileFilter/times.properties"</span>;</span><br><span class="line">		</span><br><span class="line">		getCounts(filePath);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getCounts</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">		<span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">			<span class="comment">//如果配置文件不存在，则创建该配置文件</span></span><br><span class="line">			file.createNewFile();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//创建Properties对象。</span></span><br><span class="line">		Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">		<span class="comment">//把配置文件的信息加载到properties中</span></span><br><span class="line">		properties.load(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">		FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//定义该变量是用于保存软件的运行次数的。</span></span><br><span class="line">		<span class="comment">//读取配置文件的运行次数</span></span><br><span class="line">		String value = properties.getProperty(<span class="string">"count"</span>);</span><br><span class="line">		<span class="keyword">if</span>(value!=<span class="keyword">null</span>)&#123;</span><br><span class="line">			count = Integer.parseInt(value);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//判断使用的次数是否已经达到了三次，</span></span><br><span class="line">		<span class="keyword">if</span>(count==<span class="number">3</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">"你已经超出了试用次数，请购买正版软件！！"</span>);</span><br><span class="line">			System.exit(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		count++;</span><br><span class="line">		System.out.println(<span class="string">"你已经使用了本软件第"</span>+count+<span class="string">"次"</span>);</span><br><span class="line">		properties.setProperty(<span class="string">"count"</span>,count+<span class="string">""</span>);</span><br><span class="line">		<span class="comment">//使用Properties生成一个配置文件</span></span><br><span class="line">		properties.store(fileOutputStream,<span class="string">"runtime"</span>);</span><br><span class="line">		</span><br><span class="line">		fileOutputStream.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="流和File综合练习"><a href="#流和File综合练习" class="headerlink" title="流和File综合练习"></a>流和File综合练习</h2><p>实现两个函数，一个实现文件切割功能，一个实现文件合并功能。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	File file = <span class="keyword">new</span> File(<span class="string">"/usr/Prom/eclipse/testAll/src/FileFilter/fate.mp3"</span>);</span><br><span class="line">	File dir = <span class="keyword">new</span> File(<span class="string">"/usr/Prom/eclipse/testAll/src/"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!file.exists())</span><br><span class="line">		file.createNewFile();</span><br><span class="line">	<span class="keyword">if</span>(!dir.exists())</span><br><span class="line">		dir.mkdirs();</span><br><span class="line">	</span><br><span class="line">	spiliteFile(file);</span><br><span class="line">	</span><br><span class="line">	mergeFile(dir);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 切割文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">spiliteFile</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!file.exists())</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 用读取流关联源文件。</span></span><br><span class="line">	FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">	<span class="comment">// 定义一个1M的缓冲区。</span></span><br><span class="line">	<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[SIZE];</span><br><span class="line">	<span class="comment">// 创建目的。</span></span><br><span class="line">	FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 切割文件时，必须记录住被切割文件的名称，以及切割出来碎片文件的个数。 以方便于合并。</span></span><br><span class="line"><span class="comment">	* 这个信息为了进行描述，使用键值对的方式。用到了properties对象</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">	File dir = <span class="keyword">new</span> File(<span class="string">"/usr/Prom/eclipse/testAll/src"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!dir.exists())</span><br><span class="line">		dir.mkdirs();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> ((len = fis.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">		fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(dir, (count++) + <span class="string">".part"</span>));</span><br><span class="line">		fos.write(buf, <span class="number">0</span>, len);</span><br><span class="line">		fos.close();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将被切割文件的信息保存到prop集合中。</span></span><br><span class="line">	prop.setProperty(<span class="string">"partcount"</span>, count+<span class="string">""</span>);</span><br><span class="line">	prop.setProperty(<span class="string">"filename"</span>, file.getName());</span><br><span class="line">	fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(dir,count+<span class="string">".properties"</span>));</span><br><span class="line">	<span class="comment">//将prop集合中的数据存储到文件中。</span></span><br><span class="line">	prop.store(fos, <span class="string">"save file info"</span>);</span><br><span class="line">	fos.close();</span><br><span class="line">	fis.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dir</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeFile</span><span class="params">(File dir)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 获取指定目录下的配置文件对象。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	File[] files = dir.listFiles(<span class="keyword">new</span> SuffixFilter(<span class="string">".properties"</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(files.length != <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(dir+<span class="string">",该目录下没有properties扩展名的文件或者不唯一"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//记录配置文件对象。</span></span><br><span class="line">	File confile = files[<span class="number">0</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取该文件中的信息</span></span><br><span class="line">	Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">	FileInputStream fis = <span class="keyword">new</span> FileInputStream(confile);</span><br><span class="line">	prop.load(fis);</span><br><span class="line">	String filename = prop.getProperty(<span class="string">"filename"</span>);</span><br><span class="line">	<span class="keyword">int</span> count = Integer.parseInt(prop.getProperty(<span class="string">"partcount"</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取该目录下的所有碎片文件</span></span><br><span class="line">	File[] partFiles = dir.listFiles(<span class="keyword">new</span> SuffixFilter(<span class="string">".part"</span>));</span><br><span class="line">	<span class="keyword">if</span>(partFiles.length!=(count-<span class="number">1</span>))&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">" 碎片文件不符合要求，个数不对!应该"</span>+count+<span class="string">"个"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将碎片文件和流对象关联 并存储到集合中。</span></span><br><span class="line">	ArrayList&lt;FileInputStream&gt; al = <span class="keyword">new</span> ArrayList&lt;FileInputStream&gt;();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;partFiles.length; x++)&#123;</span><br><span class="line">		al.add(<span class="keyword">new</span> FileInputStream(partFiles[x]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将多个流合并成一个序列流。</span></span><br><span class="line">	Enumeration&lt;FileInputStream&gt; en = Collections.enumeration(al);</span><br><span class="line">	SequenceInputStream sis = <span class="keyword">new</span> SequenceInputStream(en);</span><br><span class="line">	FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(dir,filename));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((len=sis.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">		fos.write(buf,<span class="number">0</span>,len);</span><br><span class="line">	&#125;</span><br><span class="line">	fos.close();</span><br><span class="line">	sis.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后缀名过滤器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> adamhand</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SuffixFilter</span> <span class="keyword">implements</span> <span class="title">FilenameFilter</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String suffix;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SuffixFilter</span><span class="params">(String suffix)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.suffix = suffix;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name.endsWith(suffix);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/Java-I-O-1-字节流与字符流/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="adamhand">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dethnote">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/Java-I-O-1-字节流与字符流/" itemprop="url">Java I/O(1)--字节流与字符流</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T21:49:23+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、概览"><a href="#一、概览" class="headerlink" title="一、概览"></a>一、概览</h1><p>Java 的 I/O 大概可以分成以下几类：</p>
<ul>
<li>字节操作：InputStream 和 OutputStream</li>
<li>字符操作：Reader 和 Writer</li>
<li>磁盘操作：File</li>
<li>对象操作：Serializable</li>
<li>网络操作：Socket</li>
<li>新的输入/输出：NIO</li>
</ul>
<h1 id="二、字节操作和字符操作——字节流和字符流"><a href="#二、字节操作和字符操作——字节流和字符流" class="headerlink" title="二、字节操作和字符操作——字节流和字符流"></a>二、字节操作和字符操作——字节流和字符流</h1><center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/iostream.png"><br></center>

<h2 id="流的概念和作用"><a href="#流的概念和作用" class="headerlink" title="流的概念和作用"></a>流的概念和作用</h2><p>流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。</p>
<h2 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h2><ul>
<li>根据处理数据类型的不同分为：字符流和字节流</li>
<li>根据数据流向不同分为：输入流和输出流</li>
</ul>
<h2 id="字符流和字节流"><a href="#字符流和字节流" class="headerlink" title="字符流和字节流"></a>字符流和字节流</h2><p>字节流的两个顶层父类：InputStream、OutputStream.</p>
<p>字符流的两个顶层父类：Reader、Writer。</p>
<p>这些体系的子类都以父类名作为后缀，而且子类名的前缀就是该对象的功能</p>
<p>字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表，简单来说，字符流=字节流+编码表。 字节流和字符流的区别：</p>
<ul>
<li>读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。</li>
<li>处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。</li>
</ul>
<p><strong>设备上的数据无论是图片或者视频，文字，它们都以二进制存储的。二进制的最终都是以一个8位为数据单元进行体现，所以计算机中的最小数据单元就是字节。意味着，字节流可以处理设备上的所有数据，所以字节流一样可以处理字符数据。</strong></p>
<p><strong>结论：只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。</strong></p>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="输入字节流-InputStream"><a href="#输入字节流-InputStream" class="headerlink" title="输入字节流 InputStream"></a>输入字节流 InputStream</h3><blockquote>
<ul>
<li>InputStream 是所有的输入字节流的父类，它是一个抽象类。</li>
<li>ByteArrayInputStream、StringBufferInputStream、FileInputStream 是三种基本的介质流，它们分别从Byte 数组、StringBuffer、和本地文件中读取数据。</li>
<li>PipedInputStream 是从与其它线程共用的管道中读取数据，与Piped 相关的知识后续单独介绍。</li>
<li>ObjectInputStream 和所有FilterInputStream 的子类都是装饰流（装饰器模式的主角）。</li>
</ul>
</blockquote>
<h3 id="输出字节流-OutputStream"><a href="#输出字节流-OutputStream" class="headerlink" title="输出字节流 OutputStream"></a>输出字节流 OutputStream</h3><blockquote>
<ul>
<li>OutputStream 是所有的输出字节流的父类，它是一个抽象类。</li>
<li>ByteArrayOutputStream、FileOutputStream 是两种基本的介质流，它们分别向Byte 数组、和本地文件中写入数据。</li>
<li>PipedOutputStream 是向与其它线程共用的管道中写入数据。</li>
<li>ObjectOutputStream 和所有FilterOutputStream 的子类都是装饰流。</li>
</ul>
</blockquote>
<h3 id="常用字节流——FileInputStrem和FileOutPutStrem"><a href="#常用字节流——FileInputStrem和FileOutPutStrem" class="headerlink" title="常用字节流——FileInputStrem和FileOutPutStrem"></a>常用字节流——FileInputStrem和FileOutPutStrem</h3><p>FileInputStrem和FileOutPutStrem的写入和读取方式有4中，如下：</p>
<blockquote>
<ul>
<li>直接读取和写入单个字节。这种方式效率很低，应该避免使用。</li>
<li>使用FileInputStrem的available方法估计流的大小，从而创建缓冲区数组。这种方法会创建一个和流文件大小相同的数组，如果流文件很大，缓冲区会很大，所以在文件比较大的时候不建议使用。</li>
<li>创建固定大小的缓冲区。推荐使用。</li>
<li>使用BufferedInputStream和BufferedOutputStream。推荐使用。</li>
</ul>
</blockquote>
<p>下面看具体的例子：</p>
<blockquote>
<ul>
<li>例子1：FileInputStrem读取文本文件中的内容并打印到控制台上。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">demoRead</span><span class="params">(String filePath)</span></span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        String result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.根据path路径数实例化一个输入流对象</span></span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">            <span class="comment">//2.返回这个流中可以被读的剩下的bytes字节的估计值</span></span><br><span class="line">            <span class="keyword">int</span> size = fis.available();</span><br><span class="line">            <span class="comment">//3.根据估计值创建缓冲数组</span></span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">            <span class="comment">//4.将数据读入缓冲数组</span></span><br><span class="line">            fis.read(buf);</span><br><span class="line">            <span class="comment">//5.将读到的数据创建成一个字符串，用于返回</span></span><br><span class="line">            result = <span class="keyword">new</span> String(buf);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fis != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String filePath = <span class="string">"D:\\Prom\\testAll\\src\\IO\\FileInputStreamDemo\\demoRead.txt"</span>;</span><br><span class="line">        String result = demoRead(filePath);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>例子2：FileOutputStrem写入文本文件。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileOutputStreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WriteDemo</span><span class="params">(String filePath, String data)</span></span>&#123;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.根据文件路径创建输出流</span></span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(filePath);</span><br><span class="line">            <span class="comment">//2.将字符串转化为数组并写入</span></span><br><span class="line">            fos.write(data.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fos != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String filePath = <span class="string">"D:\\Prom\\testAll\\src\\IO\\FileOutPutSreamDemo\\WriteDemo.txt"</span>;</span><br><span class="line"></span><br><span class="line">        WriteDemo(filePath, <span class="string">"FileOutPutStream:"</span> + <span class="string">"WriteDemo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>例子3：使用四种方式复制mp3文件。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyMp3Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//D:\Prom\testAll\src\IO\CopyMp3Demo</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String fromPath = <span class="string">"D:\\Prom\\testAll\\src\\IO\\CopyMp3Demo\\0.mp3"</span>;</span><br><span class="line">        String toPath = <span class="string">"D:\\Prom\\testAll\\src\\IO\\CopyMp3Demo\\1.mp3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        copyMp3Demo_1(fromPath, toPath);</span></span><br><span class="line"><span class="comment">//        copyMp3Demo_2(fromPath, toPath);</span></span><br><span class="line"><span class="comment">//        copyMp3Demo_3(fromPath, toPath);</span></span><br><span class="line">        copyMp3Demo_4(fromPath, toPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一个字节一个字节读取，效率很慢，不要用。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fromPath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> toPath</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyMp3Demo_1</span><span class="params">(String fromPath, String toPath)</span></span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(fromPath);</span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(toPath);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//一个字节一个字节读取</span></span><br><span class="line">            <span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((ch = fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                fos.write(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fis != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fos != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用available定义缓冲区，当文件很大的时候，缓冲区会很大，不建议使用。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fromPath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> toPath</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyMp3Demo_2</span><span class="params">(String fromPath, String toPath)</span></span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(fromPath);</span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(toPath);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[fis.available()];</span><br><span class="line">            fis.read(buf);</span><br><span class="line">            fos.write(buf);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fis != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fos != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用BufferedInputStream和BufferedOutputStream缓冲区。建议使用。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fromPath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> toPath</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyMp3Demo_3</span><span class="params">(String fromPath, String toPath)</span></span>&#123;</span><br><span class="line">        BufferedInputStream bufis = <span class="keyword">null</span>;</span><br><span class="line">        BufferedOutputStream bufos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bufis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(fromPath));</span><br><span class="line">            bufos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(toPath));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((ch = bufis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                bufos.write(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(bufis != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bufis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(bufos != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bufos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用自定义的数组缓冲区，建议使用。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fromPath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> toPath</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyMp3Demo_4</span><span class="params">(String fromPath, String toPath)</span></span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(fromPath);</span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(toPath);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((len = fis.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                fos.write(buf, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fis != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fos != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>装饰设计模式，可以在原有技能的基础上，新增技能，降低继承所带来的耦合性。装饰者和被装饰者必须实现同一个接口或者继承自同一个父类。</p>
<p>一个装饰者模式的例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecratorPattern</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Coder coder = <span class="keyword">new</span> Coder(<span class="keyword">new</span> Student());</span><br><span class="line">		coder.code();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编码技能接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">coding</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生会的编程语言：java和C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">coding</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"java"</span>);</span><br><span class="line">		System.out.println(<span class="string">"C"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生变成程序员之后又学会了一些编程语言。这个类就是装饰类。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coder</span> <span class="keyword">implements</span> <span class="title">coding</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Student student;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Coder</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.student = student;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		student.code();</span><br><span class="line">		System.out.println(<span class="string">"C#"</span>);</span><br><span class="line">		System.out.println(<span class="string">"C++"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java I/O 使用了装饰者模式来实现。以 InputStream 为例，</p>
<blockquote>
<ul>
<li>InputStream 是抽象组件；</li>
<li>FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作；</li>
<li>FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。</li>
</ul>
</blockquote>
<center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/DP-Decorator-java.io.png" width="500"><br></center>

<p>实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">BufferedInputStream bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(fileInputStream);</span><br></pre></td></tr></table></figure>
<p>DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。</p>
<h3 id="其他字节流"><a href="#其他字节流" class="headerlink" title="其他字节流"></a>其他字节流</h3><h4 id="打印流——PrintSream"><a href="#打印流——PrintSream" class="headerlink" title="打印流——PrintSream"></a>打印流——PrintSream</h4><p>PrintStream 继承于FilterOutputStream，用来装饰其它输出流。它能为其他输出流添加了功能，使它们能够按照原格式进行打印。System.out对应的类型就是PrintStream。</p>
<p>PrintStream 永远不会抛出 IOException；它产生的IOException会被自身的函数所捕获并设置错误标记。</p>
<p>它的构造函数函数可以接收三种数据类型的值。</p>
<blockquote>
<ul>
<li>字符串路径。</li>
<li>File对象。</li>
<li>OutputStream。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printStreamDemo</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	File file = <span class="keyword">new</span> File(<span class="string">"/usr/Prom/eclipse/testAll/src/FileFilter/printstream.txt"</span>);</span><br><span class="line">	<span class="keyword">if</span>(!file.exists())</span><br><span class="line">		file.createNewFile();</span><br><span class="line">	</span><br><span class="line">	PrintStream out = <span class="keyword">new</span> PrintStream(file);</span><br><span class="line">	out.write(<span class="number">610</span>);   <span class="comment">//接受的是一个byte数组，只写最低8位，结果是将b写入到文件中</span></span><br><span class="line">		</span><br><span class="line">	out.println(<span class="number">97</span>);    <span class="comment">//97</span></span><br><span class="line">	out.println(<span class="string">'a'</span>);   <span class="comment">//a</span></span><br><span class="line">	out.println(<span class="string">"hello world"</span>); <span class="comment">//hello world</span></span><br><span class="line">	out.println(<span class="keyword">true</span>);  <span class="comment">//true</span></span><br><span class="line">	out.println(<span class="number">3.14</span>);  <span class="comment">//3.14</span></span><br><span class="line">	<span class="comment">//out.println(new Student("酒香逢"));  //姓名：酒香逢</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="序列流，也称为合并流——SequenceInputStream"><a href="#序列流，也称为合并流——SequenceInputStream" class="headerlink" title="序列流，也称为合并流——SequenceInputStream:"></a>序列流，也称为合并流——SequenceInputStream:</h4><p>特点：可以将多个读取流合并成一个流。这样操作起来很方便。<br>原理：其实就是将每一个读取流对象存储到一个集合中。最后一个流对象结尾作为这个流的结尾。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sequenceInputStreamDemo</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 需求：将1.txt 2.txt 3.txt文件中的数据合并到一个文件中。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">//不推荐使用Vector对象，因为效率比较低。</span></span><br><span class="line">	<span class="comment">// Vector&lt;FileInputStream&gt; v = new Vector&lt;FileInputStream&gt;();</span></span><br><span class="line">	<span class="comment">// v.add(new FileInputStream("1.txt"));</span></span><br><span class="line">	<span class="comment">// v.add(new FileInputStream("2.txt"));</span></span><br><span class="line">	<span class="comment">// v.add(new FileInputStream("3.txt"));</span></span><br><span class="line">	<span class="comment">// Enumeration&lt;FileInputStream&gt; en = v.elements();</span></span><br><span class="line">	</span><br><span class="line">    File file1 = <span class="keyword">new</span> File(<span class="string">"/usr/Prom/eclipse/testAll/src/FileFilter/1.txt"</span>);</span><br><span class="line">    File file2 = <span class="keyword">new</span> File(<span class="string">"/usr/Prom/eclipse/testAll/src/FileFilter/2.txt"</span>);</span><br><span class="line">    File file3 = <span class="keyword">new</span> File(<span class="string">"/usr/Prom/eclipse/testAll/src/FileFilter/3.txt"</span>);</span><br><span class="line">    <span class="comment">// 如果没有目标文件就创建</span></span><br><span class="line">    <span class="keyword">if</span> (!file1.exists()) &#123;</span><br><span class="line">        file1.createNewFile();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!file2.exists()) &#123;</span><br><span class="line">        file2.createNewFile();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!file3.exists()) &#123;</span><br><span class="line">        file3.createNewFile();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将流对象放入集合中，便于合并。</span></span><br><span class="line">	ArrayList&lt;FileInputStream&gt; al = <span class="keyword">new</span> ArrayList&lt;FileInputStream&gt;();</span><br><span class="line">	al.add(<span class="keyword">new</span> FileInputStream(file1));</span><br><span class="line">	al.add(<span class="keyword">new</span> FileInputStream(file2));</span><br><span class="line">	al.add(<span class="keyword">new</span> FileInputStream(file3));</span><br><span class="line">	<span class="comment">//获取迭代器</span></span><br><span class="line">	Enumeration&lt;FileInputStream&gt; en = Collections.enumeration(al);</span><br><span class="line">	<span class="comment">//通过序列流将三个流串起来</span></span><br><span class="line">	SequenceInputStream sis = <span class="keyword">new</span> SequenceInputStream(en);</span><br><span class="line">	</span><br><span class="line">	FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"/usr/Prom/eclipse/testAll/src/FileFilter/1234.txt"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((len=sis.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">		fos.write(buf,<span class="number">0</span>,len);</span><br><span class="line">	&#125;</span><br><span class="line">	fos.close();</span><br><span class="line">	sis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><h3 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h3><p>编码就是把字符转换为字节，而解码是把字节重新组合成字符。</p>
<p>如果编码和解码过程使用不同的编码方式那么就出现了乱码。</p>
<blockquote>
<ul>
<li>GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节；</li>
<li>UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节；</li>
<li>UTF-16be 编码中，中文字符和英文字符都占 2 个字节。</li>
</ul>
</blockquote>
<p>UTF-16be 中的 be 指的是 Big Endian，也就是大端。相应地也有 UTF-16le，le 指的是 Little Endian，也就是小端。</p>
<p>Java 使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。</p>
<p><strong>补充：大端和小端：</strong><br><strong>小端字节序：</strong>低字节存于内存低地址；高字节存于内存高地址。如一个long型数据0x12345678<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　　　　　　　0x0029f458　　0x78</span><br><span class="line"></span><br><span class="line">　　　　　　　　0x0029f459　　0x56</span><br><span class="line"></span><br><span class="line">　　　　　　　　0x0029f45a　　0x34</span><br><span class="line"></span><br><span class="line">　　　　　　　　0x0029f45b　　0x12</span><br></pre></td></tr></table></figure></p>
<p>在以上数据存放于内存中的表现形式中，0x0029f458 &lt; 0x0029f459 &lt; 0x0029f45a &lt; 0x0029f45b，可以知道内存的地址是由低到高的顺序；而数据的字节也是由低到高的，故以上字节序是小端字节序。</p>
<p><strong>大端字节序：</strong>高字节存于内存低地址；低字节存于内存高地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　　　　　　　0x0029f458　　0x12</span><br><span class="line"></span><br><span class="line">　　　　　　　　0x0029f459　　0x34</span><br><span class="line"></span><br><span class="line">　　　　　　　　0x0029f45a　　0x56</span><br><span class="line"></span><br><span class="line">　　　　　　　　0x0029f45b　　0x79</span><br></pre></td></tr></table></figure></p>
<p>在以上数据存放于内存中的表现形式中，0x0029f458 &lt; 0x0029f459 &lt; 0x0029f45a &lt; 0x0029f45b，可以知道内存的地址是由低到高的顺序；而数据的字节却是由高到低的，故以上字节序是大端字节序。</p>
<p>Java提供了方法测试平台的大小端，程序如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EndianTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">endianTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN)</span><br><span class="line">            System.out.println(<span class="string">"big endian"</span>);</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		    System.out.println(<span class="string">"little endian"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		EndianTest.endianTest();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ByteOrder属于java.nio.ByteOrder，它的原理如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteOrder <span class="title">nativeOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Bits.byteOrder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ByteOrder <span class="title">byteOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (byteOrder == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Unknown byte order"</span>);</span><br><span class="line">        <span class="keyword">return</span> byteOrder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> a = unsafe.allocateMemory(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            unsafe.putLong(a, <span class="number">0x0102030405060708L</span>);</span><br><span class="line">            <span class="keyword">byte</span> b = unsafe.getByte(a);</span><br><span class="line">            <span class="keyword">switch</span> (b) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x01</span>: byteOrder = ByteOrder.BIG_ENDIAN;     <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x08</span>: byteOrder = ByteOrder.LITTLE_ENDIAN;  <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">                    byteOrder = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            unsafe.freeMemory(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以模仿着自己写一个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEndian</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">0x12345678</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">char</span> ch = (<span class="keyword">char</span>)a;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">0x12</span> == ch)&#123;</span><br><span class="line">			System.out.println(<span class="string">"大端!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">assert</span>(ch == <span class="number">0x78</span>);</span><br><span class="line">			System.out.println(<span class="string">"小端!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		TestEndian.test();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="String-的编码方式"><a href="#String-的编码方式" class="headerlink" title="String 的编码方式"></a>String 的编码方式</h3><p>String 可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为 String。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"中文"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = str1.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(bytes, <span class="string">"UTF-8"</span>);</span><br><span class="line">System.out.println(str2);</span><br></pre></td></tr></table></figure>
<p>在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 char 存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。getBytes() 的默认编码方式与平台有关，一般为 UTF-8。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = str1.getBytes();</span><br></pre></td></tr></table></figure>
<h3 id="常用字符流——FileReader和FileWriter"><a href="#常用字符流——FileReader和FileWriter" class="headerlink" title="常用字符流——FileReader和FileWriter"></a>常用字符流——FileReader和FileWriter</h3><p>与FileInputStrem和FileOutPutStrem类似，FileReader和FileWriter的写入和读取方式有3中，如下：</p>
<blockquote>
<ul>
<li>直接读取和写入单个字节。这种方式效率很低，应该避免使用。</li>
<li>创建固定大小的缓冲区。推荐使用。</li>
<li>使用BufferedInputStream和BufferedOutputStream。推荐使用。</li>
</ul>
</blockquote>
<p>具体如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个文本文件中的数据写入另一个文本文件。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReaderWriterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String fromPath = <span class="string">"D:\\Prom\\testAll\\src\\IO\\FileReaderWriterDemo\\0.txt"</span>;</span><br><span class="line">        String toPath = <span class="string">"D:\\Prom\\testAll\\src\\IO\\FileReaderWriterDemo\\1.txt"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        readWriteDemo_1(fromPath, toPath);</span></span><br><span class="line"><span class="comment">//        readWriteDemo_2(fromPath, toPath);</span></span><br><span class="line">        readWriteDemo_3(fromPath, toPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接读取写入的方式，效率低下，不建议使用。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fromPath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> toPath</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readWriteDemo_1</span><span class="params">(String fromPath, String toPath)</span></span>&#123;</span><br><span class="line">        FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">        FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fr = <span class="keyword">new</span> FileReader(fromPath);</span><br><span class="line">            fw = <span class="keyword">new</span> FileWriter(toPath);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//直接读取</span></span><br><span class="line">            <span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((ch = fr.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                fw.write(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fr != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fr.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fw != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义字符数组作为缓冲区，建议使用。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fromPath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> toPath</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readWriteDemo_2</span><span class="params">(String fromPath, String toPath)</span></span>&#123;</span><br><span class="line">        FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">        FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fr = <span class="keyword">new</span> FileReader(fromPath);</span><br><span class="line">            fw = <span class="keyword">new</span> FileWriter(toPath);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//注意和FileInputStream不同的是，这里读取的是字符，所以要新建字符数组做缓冲区。</span></span><br><span class="line">            <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>((len = fr.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                fw.write(buf, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fr != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fr.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fw != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用BufferedReader和BufferedWriter，建议使用。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fromPath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> toPath</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readWriteDemo_3</span><span class="params">(String fromPath, String toPath)</span></span>&#123;</span><br><span class="line">        BufferedReader bufr = <span class="keyword">null</span>;</span><br><span class="line">        BufferedWriter bufw = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bufr = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(fromPath));</span><br><span class="line">            bufw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(toPath));</span><br><span class="line"></span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span>((line = bufr.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                bufw.write(line);</span><br><span class="line">                bufw.newLine();</span><br><span class="line">                bufw.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(bufr != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bufr.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(bufw != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bufw.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他字符流"><a href="#其他字符流" class="headerlink" title="其他字符流"></a>其他字符流</h3><h4 id="字符打印流——PrintWriter-类比PrintStream"><a href="#字符打印流——PrintWriter-类比PrintStream" class="headerlink" title="字符打印流——PrintWriter(类比PrintStream)"></a>字符打印流——PrintWriter(类比PrintStream)</h4><p>构造函数可以接收四种类型的值。</p>
<blockquote>
<ul>
<li>字符串路径(可以指定编码表);</li>
<li>File对象(可以指定编码表);</li>
<li>OutputStream(可以指定自动刷新);</li>
<li>Writer(可以指定自动刷新);</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printWriterDemo</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	BufferedReader bufr = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">	PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(<span class="string">"/usr/Prom/eclipse/testAll/src/FileFilter/out.txt"</span>), <span class="keyword">true</span>);  <span class="comment">//true表示自动刷新</span></span><br><span class="line">	</span><br><span class="line">	String line = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">while</span>((line = bufr.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="string">"over"</span>.equals(line))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		out.println(line);</span><br><span class="line">	&#125;</span><br><span class="line">	out.close();</span><br><span class="line">	bufr.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="LineNumberReader"><a href="#LineNumberReader" class="headerlink" title="LineNumberReader"></a>LineNumberReader</h4><p>LineNumberReader是BufferedReader的子类，也是一个装饰类。它可以允许我们从文件的任一行读到任一行，还可以通过setLineNumber()方法改变当前行号。但是这个方法只是改变私有变量lineNumber的值，并不能改变文件物理的指针位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LineNumberReaderDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      </span><br><span class="line">      FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">      LineNumberReader lnr = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">int</span> i;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="comment">// create new reader</span></span><br><span class="line">         fr = <span class="keyword">new</span> FileReader(<span class="string">"/usr/Prom/eclipse/testAll/src/FileFilter/test.txt"</span>);</span><br><span class="line">         lnr = <span class="keyword">new</span> LineNumberReader(fr);</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// set current line number</span></span><br><span class="line">         lnr.setLineNumber(<span class="number">100</span>);</span><br><span class="line">         System.out.println(<span class="string">"setLineNumber(100) is invoked"</span>);</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// get current line number</span></span><br><span class="line">         i = lnr.getLineNumber();</span><br><span class="line">         System.out.println(<span class="string">"Current line number: "</span>+i);</span><br><span class="line">         </span><br><span class="line">         String line = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">while</span>((line = lnr.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	 System.out.println(lnr.getLineNumber()+<span class="string">":"</span>+line);</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">      &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// if any error occurs</span></span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// closes the stream and releases system resources</span></span><br><span class="line">         <span class="keyword">if</span>(fr!=<span class="keyword">null</span>)</span><br><span class="line">            fr.close();</span><br><span class="line">         <span class="keyword">if</span>(lnr!=<span class="keyword">null</span>)</span><br><span class="line">            lnr.close();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setLineNumber(<span class="number">100</span>) is invoked</span><br><span class="line">Current line number: <span class="number">100</span></span><br><span class="line"><span class="number">101</span>:abcde</span><br><span class="line"><span class="number">102</span>:fghij</span><br><span class="line"><span class="number">103</span>:klmno</span><br></pre></td></tr></table></figure>
<p>以下实现了从任一行读到任一行的功能：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ex7</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataReader</span><span class="params">(String nameFile, <span class="keyword">int</span> start, <span class="keyword">int</span> finish)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (start &gt; finish) &#123;  </span><br><span class="line">            System.out.println(<span class="string">"Error start or finish!"</span>);  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;  </span><br><span class="line">        LineNumberReader reader = <span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(nameFile));  </span><br><span class="line">            reader = <span class="keyword">new</span> LineNumberReader(  </span><br><span class="line">                    <span class="keyword">new</span> InputStreamReader(inputStream));  </span><br><span class="line">            <span class="keyword">int</span> lines = getTotalLines(<span class="keyword">new</span> File(nameFile));  </span><br><span class="line">            <span class="keyword">if</span> (start &lt; <span class="number">0</span> || finish &lt; <span class="number">0</span> || finish &gt; lines || start &gt; lines) &#123;  </span><br><span class="line">                System.out.println(<span class="string">"Line not found!"</span>);  </span><br><span class="line">                <span class="keyword">return</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">              </span><br><span class="line">            String line = reader.readLine();  </span><br><span class="line">            lines = <span class="number">0</span>;  </span><br><span class="line">            <span class="keyword">while</span> (line != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                lines++;  </span><br><span class="line">                <span class="keyword">if</span>(lines &gt;= start &amp;&amp; lines &lt;= finish)&#123;  </span><br><span class="line">                    System.out.println(line);  </span><br><span class="line">                &#125;  </span><br><span class="line">                line = reader.readLine();  </span><br><span class="line">            &#125;  </span><br><span class="line">            inputStream.close();  </span><br><span class="line">            reader.close();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            System.err.println(<span class="string">"IO Error"</span>);  </span><br><span class="line">            System.exit(<span class="number">0</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getTotalLines</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException</span>&#123;  </span><br><span class="line">        FileReader in = <span class="keyword">new</span> FileReader(file);  </span><br><span class="line">        LineNumberReader reader = <span class="keyword">new</span> LineNumberReader(in);  </span><br><span class="line">        String line = reader.readLine();  </span><br><span class="line">        <span class="keyword">int</span> lines = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">while</span> (line != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            lines++;  </span><br><span class="line">            line = reader.readLine();  </span><br><span class="line">        &#125;  </span><br><span class="line">        reader.close();  </span><br><span class="line">        in.close();  </span><br><span class="line">        <span class="keyword">return</span> lines;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">new</span> Ex7().dataReader(<span class="string">"/usr/Prom/eclipse/testAll/src/FileFilter/data.txt"</span>, <span class="number">2</span>, <span class="number">4</span>);  </span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">new</span> Ex7().dataReader(<span class="string">"/usr/Prom/eclipse/testAll/src/FileFilter/data.txt"</span>,<span class="number">3</span>,<span class="number">8</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="转换流——InputStreamReader-、OutputStreamWriter"><a href="#转换流——InputStreamReader-、OutputStreamWriter" class="headerlink" title="转换流——InputStreamReader 、OutputStreamWriter"></a>转换流——InputStreamReader 、OutputStreamWriter</h3><p>InputStreamReader 、OutputStreamWriter要InputStream或OutputStream作为参数，实现<strong>从字节流到字符流</strong>的转换。</p>
<p>构造函数如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader(InputStream);        <span class="comment">//通过构造函数初始化，使用的是本系统默认的编码表GBK。</span></span><br><span class="line">InputStreamReader(InputStream,String charSet);   <span class="comment">//通过该构造函数初始化，可以指定编码表。</span></span><br><span class="line">OutputStreamWriter(OutputStream);      <span class="comment">//通过该构造函数初始化，使用的是本系统默认的编码表GBK。</span></span><br><span class="line">OutputStreamwriter(OutputStream,String charSet);   <span class="comment">//通过该构造函数初始化，可以指定编码表。</span></span><br></pre></td></tr></table></figure></p>
<p>例子如下：</p>
<blockquote>
<ul>
<li>将键盘录入的信息写入到一个文本文件中。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStreamReaderDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String toPath = <span class="string">"/usr/Prom/eclipse/testAll/src/IO/to.txt"</span>;</span><br><span class="line">		inputStreamReaderDemo_1(toPath);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inputStreamReaderDemo_1</span><span class="params">(String toPath)</span> </span>&#123;</span><br><span class="line">		BufferedReader bufr = <span class="keyword">null</span>;</span><br><span class="line">		BufferedWriter bufw = <span class="keyword">null</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//将字节流转化为字符流。</span></span><br><span class="line">			bufr = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">			bufw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(toPath)));</span><br><span class="line">			</span><br><span class="line">			String line = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">while</span>((line = bufr.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="string">"over"</span>.equals(line))&#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				bufw.write(line.toUpperCase());</span><br><span class="line">				bufw.newLine();</span><br><span class="line">				bufw.flush();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e1) &#123;</span><br><span class="line">			e1.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(bufr != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					bufr.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(bufw != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					bufw.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>将一个文本文件内容显示在控制台上。其实这个功能用前面的FileInputStrem和FileOutPutStrem或者FileWriter和FileReader可以实现，先读到缓冲区中，再将缓冲区转化成字符串打印出来，可以看前面具体的例子。<br>但是前面的方式不能指定编码类型。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputStreamWriterDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String toPath = <span class="string">"/usr/Prom/eclipse/testAll/src/IO/to.txt"</span>;</span><br><span class="line">		outputStreamWriterDemo(toPath);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outputStreamWriterDemo</span><span class="params">(String fromPath)</span> </span>&#123;</span><br><span class="line">		BufferedReader bufr = <span class="keyword">null</span>;</span><br><span class="line">		BufferedWriter bufw = <span class="keyword">null</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//将字节流转化为字符流。</span></span><br><span class="line">			<span class="comment">//相比上面的程序，改变了这两行，并且加上使用“GBK”编码的限制。</span></span><br><span class="line">			bufr = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(fromPath)));</span><br><span class="line">			bufw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out, <span class="string">"GBK"</span>));</span><br><span class="line">			</span><br><span class="line">			String line = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">while</span>((line = bufr.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">				bufw.write(line.toUpperCase());</span><br><span class="line">				bufw.newLine();</span><br><span class="line">				bufw.flush();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e1) &#123;</span><br><span class="line">			e1.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(bufr != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					bufr.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(bufw != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					bufw.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>将一个文本文件中的内容以“GBK”编码的格式复制到另一个文本文件中。同样的，这个功能用前面的FileInputStrem和FileOutPutStrem或者FileWriter和FileReader可以实现，但是前面的方式不能指定编码类型。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadAndWriterDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String fromPath = <span class="string">"/usr/Prom/eclipse/testAll/src/IO/from.txt"</span>;</span><br><span class="line">		String toPath = <span class="string">"/usr/Prom/eclipse/testAll/src/IO/to.txt"</span>;</span><br><span class="line">		readAndWriterDemo(fromPath, toPath);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readAndWriterDemo</span><span class="params">(String fromPath, String toPath)</span> </span>&#123;</span><br><span class="line">		BufferedReader bufr = <span class="keyword">null</span>;</span><br><span class="line">		BufferedWriter bufw = <span class="keyword">null</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//将字节流转化为字符流。</span></span><br><span class="line">			<span class="comment">//相比上面的程序，改变了这两行，并且加上使用“GBK”编码的限制。</span></span><br><span class="line">			bufr = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(fromPath), <span class="string">"GBK"</span>));</span><br><span class="line">			bufw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(toPath), <span class="string">"GBK"</span>));</span><br><span class="line">			</span><br><span class="line">			String line = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">while</span>((line = bufr.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">				bufw.write(line.toUpperCase());</span><br><span class="line">				bufw.newLine();</span><br><span class="line">				bufw.flush();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e1) &#123;</span><br><span class="line">			e1.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(bufr != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					bufr.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(bufw != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					bufw.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/《剑指offer》题目小结-6/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="adamhand">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dethnote">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/《剑指offer》题目小结-6/" itemprop="url">《剑指offer》题目小结(6)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T21:39:56+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="26-链表中环的入口节点"><a href="#26-链表中环的入口节点" class="headerlink" title="26. 链表中环的入口节点"></a>26. 链表中环的入口节点</h1><p>题目描述：<br>&emsp; 一个链表中包含环，请找出该链表的环的入口结点。</p>
<hr>
<blockquote>
<p>思路1：使用哈希表。参看上题。</p>
</blockquote>
<hr>
<blockquote>
<p>思路2：看下图，如果链表中存在环，且环的长度为k，那么环的入口就是倒数第k个节点。现在，只要求得环的长度，就能够根据前面的<strong>链表中倒数第k个节点</strong>的思路进行求解，定义两个指针指向头结点，先让第一个指针在链表上移动n步，然后两个指针以相同的速度向前移动，当第二个指针指向环的入口结点时，第一个指针已经围绕着环走了一圈又回到了入口结点。<br>在前面的题目中判断链表中是否有环的时候，用到一快一慢两个指针，如果两个指针相遇，说明有环，且相遇的结点一定在环内。可以从这个结点出发，一边继续向前移动一边计数，当再次回到这个结点时，就可以得到环中的结点数了。<br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/entryoflooplist.png" alt=""></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到相遇点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">meetingNode</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode slow = head.next;</span><br><span class="line">    <span class="keyword">if</span>(slow == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode fast = slow.next;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast == slow)</span><br><span class="line">            <span class="keyword">return</span> fast;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="keyword">null</span>)</span><br><span class="line">            fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">findEntryNode</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    ListNode meetingNode = meetingNode(head);</span><br><span class="line">    <span class="keyword">if</span>(meetingNode == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nodeInLoop = <span class="number">1</span>;</span><br><span class="line">    ListNode node1 = meetingNode;</span><br><span class="line">    <span class="keyword">while</span>(node1.next != meetingNode)&#123;</span><br><span class="line">        node1 = node1.next;</span><br><span class="line">        nodeInLoop++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node1 = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeInLoop; i++)</span><br><span class="line">        node1 = node1.next;</span><br><span class="line"></span><br><span class="line">    ListNode node2 = head;</span><br><span class="line">    <span class="keyword">while</span>(node1 != node2)&#123;</span><br><span class="line">        node1 = node1.next;</span><br><span class="line">        node2 = node2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路三：不用求得环的长度，只需在相遇时，让一个指针在相遇点出发，另一个指针在链表首部出发，然后两个指针一次走一步，当它们相遇时，就是环的入口处。<br>证明如下：</p>
</blockquote>
<ul>
<li>假设存在环，fast以速度2运行，slow以速度1运行，在slow走到入口t时，如图（m1为在slow首次到t时fast的位置，a为h到t的距离，b为t到m1的距离，n为环的周长）：<br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/entryinaloop1.png" alt=""><br>由图知fast走的距离为a+b+xn，slow走的距离为a，又v(fast) = 2<em>v(slow)，所以x(fast) = 2</em>x(slow)，即2a = a+b+xn，因此a = b+xn。<br>m1逆时针到t的距离为n-b。</li>
<li>在首次相遇时，如图（m2为相遇点）：<br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/entryinaloop2.png" alt=""><br>由于m1逆时针到t的距离为n-b，即要达到相遇需要追赶n-b的距离，由于两者速度差为1，因此需要n-b的时间才能相遇，此时slow再次向后n-b距离，即到达m2位置与fast相遇，因为一周长度为n，因此到t的距离为 n-(n-b) = b。</li>
<li>为何令slow重新从pHead以速度1开始走，令fast从m2以速度1走？要想在入口t相遇，则需要从m2处再走b+xn的距离，刚好pHead处符合（由1)可知），所以令slow从pHead开始走。在相遇后就是入口t的位置。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">findEntryNode_1</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    ListNode meetingNode = meetingNode(head);</span><br><span class="line">    <span class="keyword">if</span>(meetingNode == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ListNode node1 = meetingNode;</span><br><span class="line">    ListNode node2 = head;</span><br><span class="line">    <span class="keyword">while</span>(node1 != node2)&#123;</span><br><span class="line">        node1 = node1.next;</span><br><span class="line">        node2 = node2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="27-反转链表"><a href="#27-反转链表" class="headerlink" title="27. 反转链表"></a>27. 反转链表</h1><p>题目描述：<br>&emsp; 定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。</p>
<hr>
<blockquote>
<p>思路一：迭代。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    ListNode reverseHead = <span class="keyword">null</span>;</span><br><span class="line">    ListNode node = head;</span><br><span class="line">    ListNode preNode = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode next = node.next;</span><br><span class="line">        <span class="keyword">if</span>(next == <span class="keyword">null</span>)</span><br><span class="line">            reverseHead = node;</span><br><span class="line">        node.next = preNode;</span><br><span class="line">        preNode = node;</span><br><span class="line">        node = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reverseHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路二：递归。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode next = head.next;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    ListNode newHead = ReverseList(next);</span><br><span class="line">    next.next = head;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="28-合并两个排序的链表"><a href="#28-合并两个排序的链表" class="headerlink" title="28. 合并两个排序的链表"></a>28. 合并两个排序的链表</h1><p>题目描述：<br>&emsp; 输入两个递增排序的链表，合并这两个链表并使得新链表中的结点仍然是按照递增排序的。</p>
<hr>
<blockquote>
<p>思路一：迭代。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新建一个链表存放排序后的链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span> (list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list1.val &lt;= list2.val) &#123;</span><br><span class="line">            cur.next = list1;</span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = list2;</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list1 != <span class="keyword">null</span>)</span><br><span class="line">        cur.next = list1;</span><br><span class="line">    <span class="keyword">if</span> (list2 != <span class="keyword">null</span>)</span><br><span class="line">        cur.next = list2;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路二：递归。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list1 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    <span class="keyword">if</span> (list2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    <span class="keyword">if</span> (list1.val &lt;= list2.val) &#123;</span><br><span class="line">        list1.next = Merge(list1.next, list2);</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list2.next = Merge(list1, list2.next);</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="29-树的子结构"><a href="#29-树的子结构" class="headerlink" title="29. 树的子结构"></a>29. 树的子结构</h1><p>题目描述：<br>&emsp; 输入两个二叉树A和B，判断B是不是A的子结构。</p>
<hr>
<blockquote>
<p>思路：</p>
</blockquote>
<ul>
<li>首先我们的思路应该是从二叉树A的根结点开始递归遍历整棵树，每访问到一个结点，都要检查当前结点是否已经是子树的开始结点，否则传入该结点的左右孩子继续检查</li>
<li>在判断当前结点是否已经是子树的开始结点时，首先判断结点值是否相等，相等的话再判断各自的左右孩子是否也对应相等（此时要注意，子树可以先为空，但二叉树A不能先为空）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//要么当前结点已经是子树 要么当前结点的左孩子或右孩子存在子树</span></span><br><span class="line">    <span class="keyword">return</span> IsSubtree(root1,root2) || HasSubtree(root1.left,root2) || HasSubtree(root1.right,root2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(root1 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(root1.val == root2.val)</span><br><span class="line">        <span class="keyword">return</span> IsSubtree(root1.left,root2.left) &amp;&amp; IsSubtree(root1.right,root2.right);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="30-二叉树的镜像"><a href="#30-二叉树的镜像" class="headerlink" title="30. 二叉树的镜像"></a>30. 二叉树的镜像</h1><p>题目描述：<br>&emsp; 请完成一个函数，输入一个二叉树，输出该二叉树的镜像。</p>
<center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/mirrorBitree.png"><br></center>

<hr>
<blockquote>
<p>思路一：使用递归。先前序遍历树的每个节点，如果遍历到的节点有子节点，就交换它的两个子节点，当交换玩素有的非叶子结点的左右子节点知乎，就得到了树的镜像。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mirrorBiTreeRecursively</span><span class="params">(BiTreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.getLeft() == <span class="keyword">null</span> &amp;&amp; root.getRight() == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    BiTreeNode node = root.getLeft();</span><br><span class="line">    root.setLeft(root.getRight());</span><br><span class="line">    root.setRight(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root.getLeft() != <span class="keyword">null</span>)</span><br><span class="line">        mirrorBiTreeRecursively(root.getLeft());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root.getRight() != <span class="keyword">null</span>)</span><br><span class="line">        mirrorBiTreeRecursively(root.getRight());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路二：非递归，使用栈。层次遍历，根节点不为 null 将根节点入队，判断队不为空时，节点出队，交换该节点的左右孩子，如果左右孩子不为空，将左右孩子入队。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代。层次遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mirrorBiTreeLevel</span><span class="params">(BiTreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.getLeft() == <span class="keyword">null</span> &amp;&amp; root.getRight() == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;BiTreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        BiTreeNode node = stack.pop();</span><br><span class="line">        swapSonNode(node);</span><br><span class="line">        <span class="keyword">if</span>(node.getRight() != <span class="keyword">null</span>)</span><br><span class="line">            stack.push(node.getRight());</span><br><span class="line">        <span class="keyword">if</span>(node.getLeft() != <span class="keyword">null</span>)</span><br><span class="line">            stack.push(node.getLeft());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swapSonNode</span><span class="params">(BiTreeNode root)</span></span>&#123;</span><br><span class="line">    BiTreeNode node = root.getLeft();</span><br><span class="line">    root.setLeft(root.getRight());</span><br><span class="line">    root.setRight(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp; 树的节点结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BiTreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> BiTreeNode left;</span><br><span class="line">    <span class="keyword">private</span> BiTreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BiTreeNode</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BiTreeNode</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BiTreeNode</span><span class="params">(<span class="keyword">int</span> value, BiTreeNode left, BiTreeNode right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BiTreeNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(BiTreeNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BiTreeNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(BiTreeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/04/《敲门恐惧症》/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="adamhand">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dethnote">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/04/《敲门恐惧症》/" itemprop="url">《敲门恐惧症》</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-04T21:37:00+08:00">
                2019-01-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/诗/" itemprop="url" rel="index">
                    <span itemprop="name">诗</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>敲门恐惧症</strong></p>
<p>我患有 敲门恐惧症<br>徘徊在门前<br>我总是犹豫着不敢敲响它<br>担心门开后露出的是一张<br>因被打搅而怏怏不乐的脸</p>
<p>因为同样的原因<br>我至今不敢叩响你的心门</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/04/《剑指offer》题目小结-5/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="adamhand">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dethnote">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/04/《剑指offer》题目小结-5/" itemprop="url">《剑指off》题目小结(5)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-04T21:25:16+08:00">
                2019-01-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="21-正则表达式匹配"><a href="#21-正则表达式匹配" class="headerlink" title="21. 正则表达式匹配"></a>21. 正则表达式匹配</h1><p>题目描述：<br>&emsp; 请实现一个函数用来匹配包含<code>&#39;.&#39;</code>和<code>&#39;*&#39;</code>的正则表达式。模式中的字符‘.’表示任意一个字符，而<code>&#39;*&#39;</code>表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串<code>&quot;aaa&quot;</code>与模式<code>&quot;a.a&quot;</code>和<code>&quot;ab*ac*a&quot;</code>匹配，但与<code>&quot;aa.a&quot;</code>及<code>&quot;ab*a&quot;</code>均不匹配。</p>
<hr>
<blockquote>
<p>分析：这道题的核心其实在于分析<code>&#39;*&#39;</code>,对于<code>&#39;.&#39;</code>来说，它和任意字符都匹配，可把其当做普通字符。对于<code>&#39;*&#39;</code>的分析，我们要进行分情况讨论，当所有的情况都搞清楚了以后，就可以写代码了。</p>
</blockquote>
<ul>
<li>在每轮匹配中，Patttern第二个字符是’*’时：<ul>
<li>第一个字符不匹配（’.’与任意字符视作匹配），那么’<em>‘只能代表匹配0次，比如’ba’与’a</em>ba’，字符串不变，模式向后移动两个字符，然后匹配剩余字符串和模式</li>
<li>第一个字符匹配，那么’<em>‘可能代表匹配0次，1次，多次，比如’aaa’与’a</em>aaa’、’aba’与’a<em>ba’、’aaaba’与’a</em>ba’。匹配0次时，字符串不变，模式向后移动两个字符，然后匹配剩余字符串和模式；匹配1次时，字符串往后移动一个字符，模式向后移动2个字符；匹配多次时，字符串往后移动一个字符，模式不变；</li>
</ul>
</li>
<li>而当Patttern第二个字符不是’*’时，情况就简单多了：<ul>
<li>如果字符串的第一个字符和模式中的第一个字符匹配，那么在字符串和模式上都向后移动一个字符，然后匹配剩余字符串和模式。</li>
<li>如果字符串的第一个字符和模式中的第一个字符不匹配，那么直接返回false。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正则表达式匹配</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Regex</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(String input,String pattern)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(input==<span class="keyword">null</span>||pattern==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> matchCore(input,<span class="number">0</span>,pattern,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">matchCore</span><span class="params">(String input,<span class="keyword">int</span> i,String pattern,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((input.length()==i)&amp;&amp;(pattern.length()==p))&#123;</span><br><span class="line">            <span class="comment">//出口1，input和pattern都到了字符串末尾</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((i!=input.length())&amp;&amp;(pattern.length()==p))&#123;</span><br><span class="line">            <span class="comment">//出口2，字符串input没有到末尾，pattern到了末尾</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((input.length()==i)&amp;&amp;(pattern.length()!=p))&#123;</span><br><span class="line">            <span class="comment">//出口3，字符串input到末尾，pattern还没有到末尾</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((p+<span class="number">1</span>&lt;pattern.length())&amp;&amp;(pattern.charAt(p+<span class="number">1</span>)==<span class="string">'*'</span>))&#123;<span class="comment">//pattern第二个字符为*</span></span><br><span class="line">            <span class="keyword">if</span>((input.charAt(i)==pattern.charAt(p))||(pattern.charAt(p)==<span class="string">'.'</span>))&#123;</span><br><span class="line">                <span class="comment">//首字母相匹配</span></span><br><span class="line">                <span class="keyword">return</span> matchCore(input,i+<span class="number">1</span>,pattern,p+<span class="number">2</span>) <span class="comment">//*表示出现1次</span></span><br><span class="line">                        ||matchCore(input,i+<span class="number">1</span>,pattern,p)    <span class="comment">//*表示出现多次</span></span><br><span class="line">                        ||matchCore(input,i,pattern,p+<span class="number">2</span>);   <span class="comment">//*表示出现0次 ， a ...  p* ...</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//首字母不匹配</span></span><br><span class="line">                <span class="keyword">return</span> matchCore(input,i,pattern,p+<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">//end pattern.charAt(p+1)=='*'</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((input.charAt(i)==pattern.charAt(p))||(pattern.charAt(p)==<span class="string">'.'</span>))&#123;</span><br><span class="line">            <span class="comment">//pattern第二个字母不是*，且首字母匹配</span></span><br><span class="line">            <span class="keyword">return</span> matchCore(input,i+<span class="number">1</span>,pattern,p+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">//其余情况全部不匹配</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);                       <span class="comment">//扫描键盘输入</span></span><br><span class="line">        System.out.println(<span class="string">" 请输入第一个字符串："</span>);</span><br><span class="line">        String str1 = scanner.nextLine();</span><br><span class="line">        System.out.println(<span class="string">" 请输入第二个字符串："</span>);</span><br><span class="line">        String str2 = scanner.nextLine();</span><br><span class="line">        scanner.close();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"匹配的结果为："</span>);</span><br><span class="line">        System.out.println(match(str1, str2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="22-表示数值的字符串"><a href="#22-表示数值的字符串" class="headerlink" title="22. 表示数值的字符串"></a>22. 表示数值的字符串</h1><p>题目描述：<br>&emsp; 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
<hr>
<blockquote>
<p>思路一：从头到尾比较。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> inx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    test(<span class="string">"Test1"</span>, <span class="string">"100"</span>, <span class="keyword">true</span>);</span><br><span class="line">    test(<span class="string">"Test2"</span>, <span class="string">"123.45e+6"</span>, <span class="keyword">true</span>);</span><br><span class="line">    test(<span class="string">"Test3"</span>, <span class="string">"+500"</span>, <span class="keyword">true</span>);</span><br><span class="line">    test(<span class="string">"Test4"</span>, <span class="string">"5e2"</span>, <span class="keyword">true</span>);</span><br><span class="line">    test(<span class="string">"Test5"</span>, <span class="string">"3.1416"</span>, <span class="keyword">true</span>);</span><br><span class="line">    test(<span class="string">"Test6"</span>, <span class="string">"600."</span>, <span class="keyword">true</span>);</span><br><span class="line">    test(<span class="string">"Test7"</span>, <span class="string">"-.123"</span>, <span class="keyword">true</span>);</span><br><span class="line">    test(<span class="string">"Test8"</span>, <span class="string">"-1E-16"</span>, <span class="keyword">true</span>);</span><br><span class="line">    test(<span class="string">"Test9"</span>, <span class="string">"1.79769313486232E+308"</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    test(<span class="string">"Test10"</span>, <span class="string">"12e"</span>, <span class="keyword">false</span>);</span><br><span class="line">    test(<span class="string">"Test11"</span>, <span class="string">"1a3.14"</span>, <span class="keyword">false</span>);</span><br><span class="line">    test(<span class="string">"Test12"</span>, <span class="string">"1+23"</span>, <span class="keyword">false</span>);</span><br><span class="line">    test(<span class="string">"Test13"</span>, <span class="string">"1.2.3"</span>, <span class="keyword">false</span>);</span><br><span class="line">    test(<span class="string">"Test14"</span>, <span class="string">"+-5"</span>, <span class="keyword">false</span>);</span><br><span class="line">    test(<span class="string">"Test15"</span>, <span class="string">"12e+5.4"</span>, <span class="keyword">false</span>);</span><br><span class="line">    test(<span class="string">"Test16"</span>, <span class="string">"."</span>, <span class="keyword">false</span>);</span><br><span class="line">    test(<span class="string">"Test17"</span>, <span class="string">".e1"</span>, <span class="keyword">false</span>);</span><br><span class="line">    test(<span class="string">"Test18"</span>, <span class="string">"+."</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String testName, String str, <span class="keyword">boolean</span> expected)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isNumeric(str.toCharArray()) == expected)</span><br><span class="line">        System.out.println(testName+<span class="string">"+Passed."</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        System.out.println(testName+<span class="string">"+Failed."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str==<span class="keyword">null</span> || str.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = scanInteger(str);</span><br><span class="line">    <span class="comment">//判断小数部分</span></span><br><span class="line">    <span class="keyword">if</span>(inx&lt;str.length &amp;&amp; str[inx]==<span class="string">'.'</span>)&#123;</span><br><span class="line">        inx = inx+<span class="number">1</span>;</span><br><span class="line">        flag = scanUInteger(str)||flag;     <span class="comment">//解释a,见代码下方</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断指数部分</span></span><br><span class="line">    <span class="keyword">if</span>(inx&lt;str.length &amp;&amp; (str[inx]==<span class="string">'e'</span> || str[inx]==<span class="string">'E'</span>))&#123;</span><br><span class="line">        inx = inx+<span class="number">1</span>;</span><br><span class="line">        flag = flag &amp;&amp; scanInteger(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag &amp;&amp; inx&gt;=str.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否是整数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">scanInteger</span><span class="params">(<span class="keyword">char</span>[] str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inx&lt;str.length &amp;&amp;(str[inx]==<span class="string">'+'</span> || str[inx]==<span class="string">'-'</span>))&#123;</span><br><span class="line">        inx = inx+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scanUInteger(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否是无符号整数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">scanUInteger</span><span class="params">(<span class="keyword">char</span>[] str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> inx1=inx;</span><br><span class="line">    <span class="keyword">while</span>(inx&lt;str.length &amp;&amp; str[inx]&gt;=<span class="string">'0'</span> &amp;&amp; str[inx]&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">        inx = inx + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inx&gt;inx1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路二：使用库函数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNumeric_1</span><span class="params">(<span class="keyword">char</span>[] str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Double number = Double.parseDouble(<span class="keyword">new</span> String(str));</span><br><span class="line">    &#125;<span class="keyword">catch</span> (NumberFormatException e)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路三：使用正则表达式。<br><code>[]</code>  ： 字符集合<br><code>()</code>  ： 分组<br><code>?</code>   ： 重复 0 ~ 1<br><code>+</code>   ： 重复 1 ~ n<br><code>*</code>   ： 重复 0 ~ n<br><code>.</code>   ： 任意字符<br><code>\\.</code> ： 转义后的 .<br><code>\\d</code> ： 数字</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNumeric_2</span><span class="params">(<span class="keyword">char</span>[] str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(str).matches(<span class="string">"[+-]?\\d*(\\.\\d+)?([eE][+-]?\\d+)?"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="23-字符流中第一个不重复的字符"><a href="#23-字符流中第一个不重复的字符" class="headerlink" title="23. 字符流中第一个不重复的字符"></a>23. 字符流中第一个不重复的字符</h1><p>题目描述：<br>&emsp; 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 </p>
<hr>
<blockquote>
<p>解题思路：可以使用HashMap存储字符和其出现的次数，但是因为HashMap遍历是无序的，还需要用用ArrayList来确定字符输入的顺序，从而得到第一个只初夏一次的字符。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">static</span> ArrayList&lt;Character&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chars = <span class="string">"google"</span>.toCharArray();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++)</span><br><span class="line">        insert(chars[i]);</span><br><span class="line">    System.out.println(firstAppearOnce());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">firstAppearOnce</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> key : list)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.get(key) == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(ch))</span><br><span class="line">        map.put(ch, map.get(ch)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        map.put(ch, <span class="number">1</span>);</span><br><span class="line">    list.add(ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="24-调整数组顺序是奇数位于偶数前面"><a href="#24-调整数组顺序是奇数位于偶数前面" class="headerlink" title="24. 调整数组顺序是奇数位于偶数前面"></a>24. 调整数组顺序是奇数位于偶数前面</h1><p>题目描述：<br>&emsp; 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分(两种情况的代码：不考虑调整后奇数的之间和偶数之间的相对位置；考虑调整后奇数之间和偶数之间的相对位置不变)。</p>
<hr>
<blockquote>
<p>思路一：使用双指针法。这种情况没有考虑调整后奇数之间和偶数之间的行对位置。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>, tail = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(head &lt; tail)&#123;</span><br><span class="line">        <span class="keyword">while</span>(head &lt; tail &amp;&amp; (arr[head] &amp; <span class="number">0x01</span>) != <span class="number">0</span>)</span><br><span class="line">            head++;</span><br><span class="line">        <span class="keyword">while</span>(head &lt; tail &amp;&amp; (arr[tail] &amp; <span class="number">0x01</span>) == <span class="number">0</span>)</span><br><span class="line">            tail--;</span><br><span class="line">        <span class="keyword">if</span>(head &lt; tail)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[head];</span><br><span class="line">            arr[head] = arr[tail];</span><br><span class="line">            arr[tail] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路二：要求保证调整后奇数之间和偶数之间的相对位置不变。需要一个辅助数组。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reOrderArray_1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 奇数个数</span></span><br><span class="line">    <span class="keyword">int</span> oddCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> val : nums)</span><br><span class="line">        <span class="keyword">if</span> ((val &amp; <span class="number">0x01</span>) != <span class="number">0</span>)</span><br><span class="line">            oddCnt++;</span><br><span class="line">    <span class="keyword">int</span>[] copy = nums.clone();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = oddCnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : copy) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((num &amp; <span class="number">0x01</span>) != <span class="number">0</span>)</span><br><span class="line">            nums[i++] = num;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nums[j++] = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="25-链表中倒数第k个节点"><a href="#25-链表中倒数第k个节点" class="headerlink" title="25. 链表中倒数第k个节点"></a>25. 链表中倒数第k个节点</h1><p>题目描述：<br>&emsp; 输入一个链表，输出该链表中倒数第K个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第一个节点。</p>
<hr>
<blockquote>
<p>思路：常规的方法是先遍历一次链表，得到链表的长度，然后再从头到尾遍历到n-k+1的地方就行了。但是这个方法显然不是最简单的方法，因为它遍历了两次。<br>当用一个指针遍历两次才能够完成工作的情况下，往往用两个指针遍历一次就能实现，这就是<strong>“双指针法”</strong>。这里定义连个指针，第一个指针从头到尾走k-1步，第二个指针保持不动。从第k步开始，第二个指针也从头指针开始遍历，它们之间的距离适中为k-1，当第一个指针走到链表尾部的时候，第二个指针指向的就是倒数第k个节点。<br>这里需要注意几个问题，保证代码的健壮性：</p>
</blockquote>
<ul>
<li>输入的链表为空。</li>
<li>输入的链表总的节点数小于k。</li>
<li>输入的参数k为0</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">Solution</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || k == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode ahead = head;</span><br><span class="line">    ListNode behind = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ahead.next != <span class="keyword">null</span>)</span><br><span class="line">            ahead = ahead.next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    behind = head;</span><br><span class="line">    <span class="keyword">while</span>(ahead.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ahead = ahead.next;</span><br><span class="line">        behind = behind.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> behind;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="25-1-相关题目1"><a href="#25-1-相关题目1" class="headerlink" title="25.1 相关题目1"></a>25.1 相关题目1</h2><p>题目描述：<br>&emsp; 求链表的中间节点。如果链表中节点的总数为奇数，返回中间节点；如果为偶数，返回中间两个节点的任意一个。</p>
<hr>
<blockquote>
<p>思路：参考双指针法，定义两个指针，同时从头结点开始遍历，一个指针一次走一步，一个指针一次走两步。当快指针走到链表末尾的时候，走得慢的指针正好在链表的中间。注意程序的健壮性。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">findCenterNode</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="comment">//链表为空或只有头结点</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//链表只存在一个节点</span></span><br><span class="line">    <span class="keyword">if</span>(head.next.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="25-2-相关题目2"><a href="#25-2-相关题目2" class="headerlink" title="25.2 相关题目2"></a>25.2 相关题目2</h2><p>题目描述：<br>&emsp; 判断一个单向链表是否形成了环形结构。</p>
<hr>
<blockquote>
<p>方法1：使用HashSet。设置一个Hashset，顺序读取链表中的节点，判断Hashset中是否有该节点的唯一标识（ID)。如果在Hashset中，说明有环；如果不在Hashset中，将节点的ID存入Hashset。<br>这种方法时间复杂度已经最优，但是因为额外申请了Hashset，所以空间复杂度不算最优。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回true说明没有环，否则说明有环。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hsCycleOrNot</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(set.contains(cur.next.value))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            set.add(cur.next.value);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>方法2：使用双指针。定义一个快指针和一个慢指针同时从链表的头结点出发，快指针一次走两步，慢指针一次走一步。如果快指针能够追上慢指针，那么链表就是有环的；如果<strong>快指针</strong>走到链表末尾都没有追上慢指针，说明没有环。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasCycleOrNot</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast.next.next != <span class="keyword">null</span>)</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fast == slow)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/02/《剑指offer》题目小结-4/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="adamhand">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dethnote">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/02/《剑指offer》题目小结-4/" itemprop="url">《剑指offer》题目小结(4)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-02T19:08:05+08:00">
                2019-01-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="16-二进制中1的个数"><a href="#16-二进制中1的个数" class="headerlink" title="16. 二进制中1的个数"></a>16. 二进制中1的个数</h1><p><strong>题目描述</strong></p>
<p>输入一个整数，输出该数二进制表示中 1 的个数(符号位不算)。</p>
<hr>
<ul>
<li>解法1，可能引起死循环的解法：首先判断该数二进制表示中最右一位是不是1，接着把输入的整数右移一位，再次判断最右一位是不是1，直到该整数变为0位置。<br>这个方法对输入整数为整数的情况是有效的，但是如果输入一个负数，右移一位就会在最左侧补1，这样该数永远不为0，就会陷入死循环。<br>但是Java中有一个逻辑右移的概念，使用逻辑右移而不是算数右移，可以避免死循环。代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOf1_1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)      <span class="comment">//去掉符号位</span></span><br><span class="line">        count = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((n &amp; <span class="number">0x01</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        n &gt;&gt;&gt;= <span class="number">1</span>;  <span class="comment">//使用逻辑右移，可以避免死循环</span></span><br><span class="line">        <span class="comment">//n &gt;&gt;= 1;  //使用算数右移，输入为负数时会产生死循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法2，常规解法：设置一个标志flag=1，每次将flag和给定的整数做与运算后，将flag左移一位，直到flag变为0，这样就能够判断输入数的每一位是不是为1。<br>这个算法循环的次数等于flag二进制的位数，如果flag是一个整数，则要循环32次。代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOf1_2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((n &amp; flag) != <span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        flag &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法3，惊喜解法：这个解法运用了一个性质，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变为0。那么一个整数的二进制表示中有多少个1，就能够进行多少次这样的操作。代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOf1_3</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)               <span class="comment">//如果n小于0的话，要剪掉符号位的1</span></span><br><span class="line">        count -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">        ++count;</span><br><span class="line">        n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法4，用Integer.bitCount()函数。代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOf1_4</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)      <span class="comment">//去掉符号位</span></span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(n) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>小结：Java中的左移和右移</strong><br>在计算机中，移位操作可以被总结如下：</p>
<center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/leftandrightshift.PNG"><br></center>

<p>对于其他语言比如C/C++，右移时选择逻辑右移还是算数右移是由编译器自己确定的，有符号数进行算数右移，无符号数进行逻辑右移。但是Java提供了一个逻辑右移运算符 &gt;&gt;&gt;，可以人为指定右移方式。Java中的移位运算可以被总结为如下：</p>
<ul>
<li><code>&lt;&lt;</code>：左移运算符，右边补0，num &lt;&lt; 1,相当于num乘以2；</li>
<li><code>&gt;&gt;</code>：算数右移运算符，左边补符号位，num &gt;&gt; 1,相当于num除以2；</li>
<li><code>&gt;&gt;&gt;</code>：逻辑右移运算符，左边补0；</li>
</ul>
<p><em>补充1：Java中的左移</em></p>
<ul>
<li>java的左右移操作的对象是补码；</li>
<li>byte、char会转成int再操作；</li>
<li>long类型不转换；</li>
<li>double、float不可进行移动操作；</li>
</ul>
<p>看下列操作：</p>
<blockquote>
<ul>
<li>System.out.println(1&lt;&lt;3);结果为8（1*2^3）</li>
<li>System.out.println(1&lt;&lt;31);结果为-2147483648（符号位变为1，为什么变为1呢？因为这是个<strong>临界值</strong>）</li>
<li>System.out.println(1&lt;&lt;32);结果为1（不是0，<code>&lt;&lt;n</code>实际是<code>&lt;&lt;(n%32)</code>，对于<code>long&lt;&lt;n</code>实际是<code>&lt;&lt;n%64)</code>)</li>
</ul>
</blockquote>
<p><em>补充2：源码、反码和补码</em></p>
<ul>
<li>原码就是符号位加上真值的绝对值， 即用第一位表示符号， 其余位表示值。</li>
<li>反码的表示方法是:正数的反码是其本身；负数的反码是在其原码的基础上， 符号位不变，其余各个位取反。</li>
<li>补码的表示方法是:正数的补码就是其本身；负数的补码是在其原码的基础上， 符号位不变， 其余各位取反， 最后+1。 (即在反码的基础上+1)</li>
</ul>
<p>举例：<br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/threecode.PNG"></p>
<p>那么计算机为什么要使用补码呢？</p>
<p>首先，根据运算法则减去一个正数等于加上一个负数， 即: 1-1 = 1+(-1)， 所以计算机被设计成只有加法而没有减法， 而让计算机辨别”符号位”会让计算机的基础电路设计变得十分复杂，于是就让符号位也参与运算，从而产生了反码。 </p>
<p>用反码计算， 出现了”0”这个特殊的数值， 0带符号是没有任何意义的。 而且会有[0000 0000]和[1000 0000]两个编码表示0。于是设计了补码， 负数的补码就是反码+1，正数的补码就是正数本身，从而解决了0的符号以及两个编码的问题: 用[0000 0000]表示0，用[1000 0000]表示-128。 </p>
<p>注意：-128实际上是使用以前的-0的补码来表示的， 所以-128并没有原码和反码。使用补码， 不仅仅修复了0的符号以及存在两个编码的问题， 而且还能够多表示一个最低数。 这就是为什么8位二进制， 使用补码表示的范围为[-128， 127]。</p>
<p>求补码的两种方式：</p>
<ul>
<li>先写出对应的原码，然后符号位不变，除符号位外逐位取反，最后再加1；</li>
<li>先写出对应的原码，然后根据原码从右往左找出第一个1，这个1不变，符号位不变，1左边的全部去反，右边的也不变。；</li>
</ul>
<p><em>补充3：循环左移</em><br><strong>整数的循环移位：</strong></p>
<ul>
<li>确定要操作数据类型的位数L；（如<code>byte b</code>的L=8）</li>
<li>确定要循环左移的位数<code>n(n&lt;L)</code>；（如循环左移3位）</li>
<li>原数数据左移n   取或   原数据<strong>逻辑右移</strong><code>L-n</code>;   <code>(b=(byte)(b&lt;&lt;3|b&gt;&gt;&gt;5))</code>   （循环右移的话就：<code>&gt;&gt;&gt;n</code>|<code>&lt;&lt;L-n</code>）</li>
</ul>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopLeftShift</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0xD6485F0F</span>;<span class="comment">//转为2进制是32位</span></span><br><span class="line">        <span class="comment">//循环左移7位</span></span><br><span class="line">        <span class="keyword">int</span> temp=a&lt;&lt;<span class="number">7</span>|a&gt;&gt;&gt;(<span class="number">32</span>-<span class="number">7</span>);<span class="comment">//这里注意右移用的是无符号右移</span></span><br><span class="line">        System.out.println(Integer.toHexString(temp));<span class="comment">//正确答案是0x242F87EB</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环右移7位</span></span><br><span class="line">        temp=a&gt;&gt;&gt;<span class="number">7</span>|a&lt;&lt;(<span class="number">32</span>-<span class="number">7</span>);<span class="comment">//这里注意右移用的是无符号右移</span></span><br><span class="line">        System.out.println(Integer.toHexString(temp));<span class="comment">//正确答案是0x1fac90be</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>字符串的循环移位：</strong><br>核心思想：<strong>三次翻转</strong>。</p>
<p><strong>循环左移n位</strong>:</p>
<ul>
<li>先整体反转：首先将原字符串进行反转；</li>
<li>再部分反转：把整个字符串分成 原字符串的长度-n和后n个字符并分别进行反转；</li>
<li>最后合并：合并两个字符串；</li>
</ul>
<p><strong>循环右移n位</strong>:</p>
<ul>
<li>先部分反转：把原字符串分成 原字符串的长度-n和后n个字符并分别进行反转；</li>
<li>合并：合并两个字符串；</li>
<li>整体反转：再次进行反转；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串翻转</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] strs = str.toCharArray();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length() / <span class="number">2</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = strs[i];</span><br><span class="line">        strs[i] = strs[str.length() - i - <span class="number">1</span>];</span><br><span class="line">        strs[str.length() - i - <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(strs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环左移</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">loopLeftShift</span><span class="params">(String str, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    str = reverse(str);</span><br><span class="line">    String left = reverse(str.substring(<span class="number">0</span>, str.length() - index));  <span class="comment">//substring(int beginIndex, int endIndex)</span></span><br><span class="line">    String right = reverse(str.substring(str.length() - index));  <span class="comment">//substring(int beginIndex)</span></span><br><span class="line">    str = left + right;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环右移</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">loopRightShift</span><span class="params">(String str, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    String left = reverse(str.substring(<span class="number">0</span>, str.length() - index));</span><br><span class="line">    String right = reverse(str.substring(str.length() - index));</span><br><span class="line">    str = left + right;</span><br><span class="line">    str = reverse(str);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="16-1-相关题目1"><a href="#16-1-相关题目1" class="headerlink" title="16.1 相关题目1"></a>16.1 相关题目1</h2><p>题目描述：用一条语句判断一个整数是不是2的整数次方。</p>
<p>分析：一个整数如果是2的整数次方，那么它的二进制表示中有且只有一位是1，其它位都是0；那么将这个数减去1之后和自身做与运算，这个整数就会变为0。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isIntegerMultipleOf2</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((num &amp; (num - <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="16-2-相关题目2"><a href="#16-2-相关题目2" class="headerlink" title="16.2 相关题目2"></a>16.2 相关题目2</h2><p>题目描述：输入两个整数m和n，计算需要改变m的二进制表示中的多少位才能得到n。比如10的二进制表示为1010,13的二进制表示为1101，需要改变1010中的3位才能得到1101。</p>
<p>分析：可以分两步解决这个问题，第一步求这两个数的异或，第二步统计异或结果中1的位数。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">changeNumber</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//需要改变的次数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> xor = m ^ n;</span><br><span class="line">    System.out.println(xor);</span><br><span class="line">    <span class="keyword">while</span>(xor != <span class="number">0</span>)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        xor &amp;= (xor - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：由于负数在计算机中是以补码的形式存储的，所以如果输入m=-1，n=10，输入结果为30。-7在计算机中的表示为<code>1111 1111 1111 1111 1111 1111 1111 1001</code>,10表示为<code>0000 0000 0000 0000 0000 0000 0000 1010</code>。</p>
</blockquote>
<h1 id="17-数值的整数次方"><a href="#17-数值的整数次方" class="headerlink" title="17. 数值的整数次方"></a>17. 数值的整数次方</h1><p><strong>题目描述</strong><br>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不要考虑大数问题。</p>
<hr>
<p>思路：本体需要注意以下四点：</p>
<ul>
<li>0的0次方在数学上是没有意义的，因此无论是输出1还是0都是可以接受的，本题选择输出1</li>
<li>0的负数次方相当于0作为除数，也是无意义的，非法输入</li>
<li>base如果非0，如果指数exponent小于0，可以先求base的|exponent|次方，然后再求倒数</li>
<li>判断double类型的base是否等于0不能使用==号。因为计算机表述小树(包括float和double型小数)都有误差，不能直接使用等号(==)判断两个小数是否相等。如果两个数的差的绝对值很小，那么可以认为两个double类型的数相等。</li>
</ul>
<p>根据以上的思考，可以写出如下程序：</p>
<ul>
<li>解法1，普通解法：代码如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">powerWithUnsignedExponent</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= exponent; i++)</span><br><span class="line">        result *= base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isNegtive = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//底数为0且指数为负数，为了避免对0求导数出现的错误，直接返回0.0</span></span><br><span class="line">    <span class="keyword">if</span>(Math.abs(base - <span class="number">0.0</span>) &lt; Double.MIN_VALUE &amp;&amp; exponent &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        exponent = -exponent;</span><br><span class="line">        isNegtive = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> result = powerWithUnsignedExponent(base, exponent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isNegtive ? <span class="number">1.0</span> / result : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法2，高效解法：有这样一种思路，如果输入的指数为32，那么可以先求16次方，要求16次方可以先求8次方，同理，可以先求4次方，2次方，1次方。可以用如下公示表示：<center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/latex11111.PNG"><br></center>

</li>
</ul>
<p>上述公式中，a相当于base，n相当于exponent。这个公式很容易就能用递归来实现。代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">powerWithUnsignedExponent</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//0的0次方也输出1</span></span><br><span class="line">    <span class="keyword">if</span>(exponent == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(exponent == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//result相当于base^n/2</span></span><br><span class="line">    <span class="comment">//用移位运算代替除以2，效率高</span></span><br><span class="line">    <span class="keyword">double</span> result = powerWithUnsignedExponent(base, exponent &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    result *= result;</span><br><span class="line">    <span class="comment">//如果exponent为奇数，还要乘以base</span></span><br><span class="line">    <span class="comment">//用位运算代替求余操作(%)来判断一个数是奇数还是偶数</span></span><br><span class="line">    <span class="keyword">if</span>((exponent &amp; <span class="number">0x01</span>) == <span class="number">1</span>)</span><br><span class="line">        result *= base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isNegtive = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//底数为0且指数为负数，为了避免对0求导数出现的错误，直接返回0.0</span></span><br><span class="line">    <span class="keyword">if</span>(Math.abs(base - <span class="number">0.0</span>) &lt; Double.MIN_VALUE &amp;&amp; exponent &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        exponent = -exponent;</span><br><span class="line">        isNegtive = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> result = powerWithUnsignedExponent(base, exponent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isNegtive ? <span class="number">1.0</span> / result : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="18-打印从-1-到最大的-n-位数"><a href="#18-打印从-1-到最大的-n-位数" class="headerlink" title="18. 打印从 1 到最大的 n 位数"></a>18. 打印从 1 到最大的 n 位数</h1><p><strong>题目描述</strong><br>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数即 999。</p>
<hr>
<p>本题需要注意的是“大数问题”，如果n非常大，用int或long型变量存储会产生溢出。</p>
<ul>
<li>解法1，没考虑大数问题：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print1ToMaxOfNDigit</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i++ &lt; n)&#123;</span><br><span class="line">        number *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//number-1是最大的n位数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; number; j++)&#123;</span><br><span class="line">        System.out.println(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法2，用字符串模拟加法，解决大数问题。首先把字符串中的每一个数字都初始化为’0’，然后每一次为字符串表示的数字加1,。因此只需要做两件事：一是在字符串上模拟加法，二是吧字符串表达的数字打印出来。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印1到最大的n位数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneToN</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        print1ToMaxOfN(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print1ToMaxOfN</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        StringBuilder number = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        System.out.println(number.length());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            number.append(<span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!increment(number))&#123;</span><br><span class="line">            printNumber(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">increment</span><span class="params">(StringBuilder sb)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isOverflow = <span class="keyword">false</span>;        <span class="comment">//是否最高位溢出</span></span><br><span class="line">        <span class="keyword">int</span> nTakeOver = <span class="number">0</span>;                 <span class="comment">//进位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sb.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> nSum = sb.charAt(i) - <span class="string">'0'</span> + nTakeOver; <span class="comment">//某位上的数加上进位</span></span><br><span class="line">            <span class="keyword">if</span>(i == sb.length() - <span class="number">1</span>)  <span class="comment">//如果当前位为最低位，最低位加一</span></span><br><span class="line">                nSum++;</span><br><span class="line">            <span class="keyword">if</span>(nSum &gt;= <span class="number">10</span>)&#123;          <span class="comment">//要产生进位</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                    isOverflow = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    nSum -= <span class="number">10</span>;</span><br><span class="line">                    nTakeOver = <span class="number">1</span>; <span class="comment">//进位</span></span><br><span class="line">                    sb.setCharAt(i, (<span class="keyword">char</span>)(<span class="string">'0'</span>+nSum));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.setCharAt(i, (<span class="keyword">char</span>)(<span class="string">'0'</span>+ nSum));  <span class="comment">//不产生进位，也就不需要运算高位，直接跳出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isOverflow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNumber</span><span class="params">(StringBuilder sb)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isBegin0 = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//因为字符串前面补得是'0'，打印时要跳过这些0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sb.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isBegin0 &amp;&amp; sb.charAt(i) != <span class="string">'0'</span>)</span><br><span class="line">                isBegin0 = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(!isBegin0)</span><br><span class="line">                System.out.print(sb.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法3，转化成排列问题，使用递归让代码更简洁。因为n位所有十进制数其实就是n个从0到9的全排列。也就是说，把数字的每一位都从0到9排列一遍，就得到了所有的十进制数。而全排列很容易用递归来表达。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print1ToMaxOfNDigits_3</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuffer s = <span class="keyword">new</span> StringBuffer(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        s.append(<span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        s.setCharAt(<span class="number">0</span>, (<span class="keyword">char</span>) (i+<span class="string">'0'</span>));</span><br><span class="line">        Print1ToMaxOfNDigits_3_Recursely(s, n, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print1ToMaxOfNDigits_3_Recursely</span><span class="params">(StringBuffer s, <span class="keyword">int</span> n , <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == n - <span class="number">1</span>)&#123;</span><br><span class="line">        PrintNumber(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//设置某一位的数</span></span><br><span class="line">        s.setCharAt(index+<span class="number">1</span>, (<span class="keyword">char</span>) (i+<span class="string">'0'</span>));</span><br><span class="line">        <span class="comment">//第一次递归设置十位数，第二次设置百位数......</span></span><br><span class="line">        Print1ToMaxOfNDigits_3_Recursely(s, n, index+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintNumber</span><span class="params">(StringBuffer s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isBeginning0 = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isBeginning0 &amp;&amp; s.charAt(i) != <span class="string">'0'</span>)&#123;</span><br><span class="line">            isBeginning0 = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!isBeginning0)&#123;</span><br><span class="line">            System.out.print(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>补充：排列组合的递归实现</strong></p>
<ul>
<li>排列问题：输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc，则输出由字符a、b、c所能排列出来的所有字符串abc、acb、bac、bca、cab和cba。<br>可以这样想：固定第一个字符a，求后面两个字符bc的排列。当两个字符bc的排列求好之后，我们把第一个字符a和后面的b交换，得到bac，接着我们固定第一个字符b，求后面两个字符ac的排列。现在是把c放到第一位置的时候了。记住前面我们已经把原先的第一个字符a和后面的b做了交换，为了保证这次c仍然是和原先处在第一位置的a交换，我们在拿c和第一个字符交换之前，先要把b和a交换回来。在交换b和a之后，再拿c和处在第一位置的a进行交换，得到cba。我们再次固定第一个字符c，求后面两个字符b、a的排列。这样写成递归程序如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">char</span>[] array, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index==array.length)&#123;</span><br><span class="line">        System.out.println(array);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(array.length==<span class="number">0</span>||index&lt;<span class="number">0</span>||index&gt;array.length)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=index;j&lt;array.length;j++)&#123;</span><br><span class="line">        <span class="keyword">char</span> temp=array[j];</span><br><span class="line">        array[j]=array[index];</span><br><span class="line">        array[index]=temp;</span><br><span class="line">        permutation(array, index+<span class="number">1</span>);</span><br><span class="line">        temp=array[j];</span><br><span class="line">        array[j]=array[index];</span><br><span class="line">        array[index]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">调用：permutation(chars, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>组合问题：输入一个字符串，输出该字符串中字符的所有组合。举个例子，如果输入abc，它的组合有a、b、c、ab、ac、bc、abc。<br>假设我们想在长度为n的字符串中求m个字符的组合。我们先从头扫描字符串的第一个字符。针对第一个字符，我们有两种选择：一是把这个字符放到组合中去，接下来我们需要在剩下的n-1个字符中选取m-1个字符；二是不把这个字符放到组合中去，接下来我们需要在剩下的n-1个字符中选择m个字符。这两种选择都很容易用递归实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">combiantion</span><span class="params">(<span class="keyword">char</span> chs[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(chs==<span class="keyword">null</span>||chs.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Character&gt; list=<span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=chs.length;i++)&#123;</span><br><span class="line">        combine(chs,<span class="number">0</span>,i,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从字符数组中第begin个字符开始挑选number个字符加入list中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">combine</span><span class="params">(<span class="keyword">char</span> []cs,<span class="keyword">int</span> begin,<span class="keyword">int</span> number,List&lt;Character&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number==<span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(list.toString());</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(begin==cs.length)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    list.add(cs[begin]);</span><br><span class="line">    combine(cs,begin+<span class="number">1</span>,number-<span class="number">1</span>,list);</span><br><span class="line">    list.remove((Character)cs[begin]);</span><br><span class="line">    combine(cs,begin+<span class="number">1</span>,number,list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="19-在O-1-的时间内删除链表节点"><a href="#19-在O-1-的时间内删除链表节点" class="headerlink" title="19. 在O(1)的时间内删除链表节点"></a>19. 在O(1)的时间内删除链表节点</h1><p>题目描述：<br>给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。</p>
<hr>
<p>思路：</p>
<ul>
<li>如果该节点不是尾节点，那么可以直接将下一个节点的值赋给该节点，然后令该节点指向下下个节点，再删除下一个节点，时间复杂度为 O(1)。<br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/deletenode1.png" alt=""></li>
<li>否则，就需要先遍历链表，找到节点的前一个节点，然后让前一个节点指向 null，时间复杂度为 O(N)。<br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/deletenode2.png" alt=""><br>综上，如果进行 N 次操作，那么大约需要操作节点的次数为 N-1+N=2N-1，其中 N-1 表示 N-1 个不是尾节点的每个节点以 O(1) 的时间复杂度操作节点的总次数，N 表示 1 个尾节点以 O(N) 的时间复杂度操作节点的总次数。(2N-1)/N ~ 2，因此该算法的平均时间复杂度为 O(1)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    ListNode nextNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, ListNode tobeDelete)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || tobeDelete == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (tobeDelete.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 要删除的节点不是尾节点</span></span><br><span class="line">        ListNode next = tobeDelete.next;</span><br><span class="line">        tobeDelete.val = next.val;</span><br><span class="line">        tobeDelete.next = next.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != tobeDelete)</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        cur.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="20-删除链表中的重复元素"><a href="#20-删除链表中的重复元素" class="headerlink" title="20. 删除链表中的重复元素"></a>20. 删除链表中的重复元素</h1><p><strong>题目描述</strong><br>给定排序的链表，删除重复元素，只保留重复元素第一次出现的结点； </p>
<hr>
<ul>
<li>思路一：两个指针分别指向链表的第一个结点及第二个结点，即 pre 指向第一个结点、cur 指向第二个结点；若 pre.value == cur.value，则 pre 的 next 指向 cur 的 next ，cur 指向 cur 的 next ；若不等，则 pre 指向 cur，cur 指向 cur 的 next；直到循环结束；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除链表中重复的结点值，只保留第一个重复结点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 链表的头结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteRepeteNode</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    Node pre = head.next;</span><br><span class="line">    Node cur;</span><br><span class="line">    <span class="keyword">while</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cur = pre.next;</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="keyword">null</span> &amp;&amp; (pre.value == cur.value)) &#123;</span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>思路二：采用递归。注意，这种方法将所有的重复元素全部删除了，没有保留一个，所以严格来说不符合题目要求。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">deleteDuplication</span><span class="params">(Node pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead == <span class="keyword">null</span>||pHead.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    <span class="keyword">if</span>(pHead.value == pHead.next.value)&#123;<span class="comment">//第一个节点是重复节点，则跳过重复节点</span></span><br><span class="line">        Node node = pHead.next;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>&amp;&amp;node.value == pHead.value)</span><br><span class="line">            node = node.next;</span><br><span class="line">        <span class="keyword">return</span> deleteDuplication(node);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//第一个节点不是重复节点</span></span><br><span class="line">        pHead.next = deleteDuplication(pHead.next);</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>思路三：采用指针。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteDuplication</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    Node pre = head.next;</span><br><span class="line">    Node cur = pre.next;</span><br><span class="line">    <span class="keyword">while</span>(pre != <span class="keyword">null</span> &amp;&amp; cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.value == cur.value)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur.value == cur.next.value)</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">            cur = pre.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试函数和Node结构。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] num = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    Node head = <span class="keyword">new</span> Node();</span><br><span class="line">    Node pre = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(num[i]);</span><br><span class="line">        pre.next = node;</span><br><span class="line">        pre = node;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(<span class="string">"删除重复结点前的链表："</span>);</span><br><span class="line">    print(head.next);</span><br><span class="line">    deleteRepeteNode(head);</span><br><span class="line"><span class="comment">//        Node delete = deleteDuplication(head);</span></span><br><span class="line">    System.out.print(<span class="string">"删除重复结点后的链表："</span>);</span><br><span class="line">    print(head.next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%89%91%E6%8C%87%20offer%20%E9%A2%98%E8%A7%A3.md" target="_blank" rel="noopener">《剑指offer》题解</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/02/《剑指offer》题目小结-3/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="adamhand">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dethnote">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/02/《剑指offer》题目小结-3/" itemprop="url">《剑指offer》题目小结(3)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-02T19:07:59+08:00">
                2019-01-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="11-矩形覆盖问题"><a href="#11-矩形覆盖问题" class="headerlink" title="11. 矩形覆盖问题"></a>11. 矩形覆盖问题</h1><p>我们可以用 2<em>1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2</em>1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？</p>
<p>解题思路：显然这又是一个斐波那契数列问题。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pre1 = <span class="number">1</span>, pre2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= target; i++)&#123;</span><br><span class="line">            result = pre1 + pre2;</span><br><span class="line">            pre1 = pre2;</span><br><span class="line">            pre2 = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="12-旋转数组的最小数字"><a href="#12-旋转数组的最小数字" class="headerlink" title="12. 旋转数组的最小数字"></a>12. 旋转数组的最小数字</h1><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组 {3, 4, 5, 1, 2} 为 {1, 2, 3, 4, 5} 的一个旋转，该数组的最小值为 1。NOTE：给出的所有元素都大于 0，若数组大小为 0，请返回 0</p>
<p>解题思路：可以采用二分查找的方法。但是有一个问题，如果出现<code>array[leftIndex]==array[minIndex]==array[rightIndex]</code>的情况，无法确定解在哪个区间，需要切换到顺序查找。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"输入数组不符合要求"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rightIndex = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> midIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(array[leftIndex] &gt;= array[rightIndex])&#123;</span><br><span class="line">            <span class="keyword">if</span>(rightIndex - leftIndex == <span class="number">1</span>)&#123;</span><br><span class="line">                midIndex = rightIndex;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            midIndex = (leftIndex + rightIndex) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//如果leftIndex minIndex rightIndex指向的三个数的值相同，则只能采取顺序查找的方法。</span></span><br><span class="line">            <span class="keyword">if</span>(array[leftIndex] == array[midIndex] &amp;&amp; array[midIndex] == array[rightIndex])&#123;</span><br><span class="line">                <span class="keyword">return</span> minInOrder(array, leftIndex, rightIndex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(array[midIndex] &gt;= array[leftIndex])&#123;</span><br><span class="line">                leftIndex = midIndex;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[midIndex] &lt;= array[rightIndex])&#123;</span><br><span class="line">                rightIndex = midIndex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[midIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//顺序查找</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">minInOrder</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = array[index1];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index1+<span class="number">1</span>; i &lt; index2; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result &gt; array[i])&#123;</span><br><span class="line">                result = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="13-矩阵中的路径"><a href="#13-矩阵中的路径" class="headerlink" title="13. 矩阵中的路径"></a>13. 矩阵中的路径</h1><p>待续。</p>
<h1 id="14-机器人的运动范围"><a href="#14-机器人的运动范围" class="headerlink" title="14. 机器人的运动范围"></a>14. 机器人的运动范围</h1><p>待续。</p>
<h1 id="15-剪绳子"><a href="#15-剪绳子" class="headerlink" title="15. 剪绳子"></a>15. 剪绳子</h1><p>待续。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E5%89%91%E6%8C%87%20offer%20%E9%A2%98%E8%A7%A3.md" target="_blank" rel="noopener">《剑指offer》题解</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/02/Java并发-6-Volatile/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="adamhand">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dethnote">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/02/Java并发-6-Volatile/" itemprop="url">Java并发(6)--Volatile</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-02T18:59:24+08:00">
                2019-01-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java并发之volatile"><a href="#Java并发之volatile" class="headerlink" title="Java并发之volatile"></a>Java并发之volatile</h1><hr>
<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>volatile让变量每次在使用的时候，都从主存中取。而不是从各个线程的“工作内存”。Volatile 变量具有 synchronized 的可见性性和有序性，但是不具备原子特性，所以，volatile变量并不保证并发的正确性。</p>
<p>在Java内存模型中，有main memory，每个线程也有自己的memory (例如寄存器)。为了性能，一个线程会在自己的memory中保持要访问的变量的副本。这样就会出现同一个变量在某个瞬间，在一个线程的memory中的值可能与另外一个线程memory中的值，或者main memory中的值不一致的情况。一个变量声明为volatile，就意味着这个变量是随时会被其他线程修改的，因此不能将它cache在线程memory中。</p>
<p>假如多个线程同时执行i++，volatile只能保证他们操作的i是同一块内存，但依然可能出现写入脏数据的情况。</p>
<p>volatile是非阻塞的。</p>
<h1 id="volatile关键字的作用"><a href="#volatile关键字的作用" class="headerlink" title="volatile关键字的作用"></a>volatile关键字的作用</h1><blockquote>
<ul>
<li>保证可见性(参看下面的 “Volatile的实现原理”)</li>
<li>禁止指令重排</li>
</ul>
</blockquote>
<p>这里来看看第二个作用：禁止指令重排。</p>
<p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段，现代 CPU中指令的执行次序不一定按顺序执行，没有相关性的指令可以打乱次序执行，以充分利用 CPU的指令流水线，提高执行速度(具体参见<a href="https://blog.csdn.net/shunqixing/article/details/80220493" target="_blank" rel="noopener">指令重排</a>)。但是重排序也需要遵守一定规则：</p>
<blockquote>
<ul>
<li>重排序操作不会对存在数据依赖关系的操作进行重排序。比如：a=1;b=a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。</li>
<li>重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变。</li>
</ul>
</blockquote>
<p>若用volatile修饰共享变量，在编译时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序</p>
<p>内存屏障是在代码中使用一些特殊指令，如ARM中的dmb、dsb和isb指令，x86中的sfence、lfence和mfence指令。CPU遇到这些特殊指令后，要等待前面的指令执行完成才执行后面的指令。这些指令的作用就好像一道屏障把前后指令隔离开了，防止CPU把前后两段指令颠倒执行(具体参见<a href="https://blog.csdn.net/alextan_/article/details/51284078" target="_blank" rel="noopener">内存屏障</a>)。</p>
<h1 id="正确使用-volatile-变量的条件"><a href="#正确使用-volatile-变量的条件" class="headerlink" title="正确使用 volatile 变量的条件"></a>正确使用 volatile 变量的条件</h1><p>要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：</p>
<blockquote>
<ul>
<li>对变量的写操作不依赖于当前值。</li>
<li>该变量没有包含在具有其他变量的不变式中。</li>
</ul>
</blockquote>
<p>第一个条件的限制使 volatile 变量不能用作线程安全计数器。虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性。实现正确的操作需要使 x 的值在操作期间保持不变，而 volatile 变量无法实现这点。（然而，如果将值调整为只从单个线程写入，那么可以忽略第一个条件。）</p>
<p>例子如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//使用CountDownLatch来等待计算线程执行完</span></span><br><span class="line">    <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">30</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//开启30个线程进行累加操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10000</span>;j++)&#123;</span><br><span class="line">                        num++;<span class="comment">//自加操作</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等待计算线程执行完</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果为(可能每次都不一样，但应该是一个小于300000的数)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">224291</span></span><br></pre></td></tr></table></figure></p>
<p>如果用volatile修饰的共享变量可以保证可见性，那么结果应该是300000。</p>
<p>问题就出在num++这个操作上，因为num++不是个原子性的操作，而是个复合操作，由这三步组成:</p>
<blockquote>
<ul>
<li>读取</li>
<li>加一</li>
<li>赋值</li>
</ul>
</blockquote>
<p>所以，在多线程环境下，有可能线程A将num读取到本地内存中，此时其他线程可能已经将num增大了很多，线程A依然对过期的num进行自加，重新写到主存中，最终导致了num的结果不合预期，而是小于300000。</p>
<p>第二个条件可以用下面的一个例子说明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberRange</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> lower, upper;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLower</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> lower; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUpper</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> upper; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLower</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (value &gt; upper) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(...);</span><br><span class="line">        lower = value;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpper</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (value &lt; lower) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(...);</span><br><span class="line">        upper = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将 lower 和 upper 字段定义为 volatile 类型不能够充分实现类的线程安全；从而仍然需要使用同步。否则，如果凑巧两个线程在同一时间使用不一致的值执行 setLower 和 setUpper 的话，则会使范围处于不一致的状态。例如，如果初始状态是 (0, 5)，同一时间内，线程 A 调用 setLower(4) 并且线程 B 调用 setUpper(3)，显然这两个操作交叉存入的值是不符合条件的，使得最后的范围值是 (4, 3) —— 一个无效值。至于针对范围的其他操作，我们需要使 setLower() 和 setUpper() 操作原子化 —— 而将字段定义为 volatile 类型是无法实现这一目的的。</p>
<h1 id="volatile的实现原理"><a href="#volatile的实现原理" class="headerlink" title="volatile的实现原理"></a>volatile的实现原理</h1><p>在x86处理器下通过工具获取JIT编译器生成的汇编指令来看看对Volatile进行写操作CPU会做什么事情。</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>代码</th>
</tr>
</thead>
<tbody>
<tr>
<td>Java代码：</td>
<td>instance = new Singleton();    //instance是volatile变量</td>
</tr>
<tr>
<td>汇编代码：</td>
<td>0x01a3de1d: movb $0x0,0x1104800(%esi);0x01a3de24: <strong>lock</strong> addl $0x0,(%esp);</td>
</tr>
</tbody>
</table>
<p>有volatile变量修饰的共享变量进行写操作的时候会多第二行汇编代码，通过查IA-32架构软件开发者手册可知，lock前缀的指令在多核处理器下会引发了两件事情。</p>
<ul>
<li>将当前处理器缓存行的数据会写回到系统内存。</li>
<li>这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。</li>
</ul>
<p>这就是<strong>“缓存一致性”</strong>。</p>
<h1 id="正确使用-volatile-的模式"><a href="#正确使用-volatile-的模式" class="headerlink" title="正确使用 volatile 的模式"></a>正确使用 volatile 的模式</h1><p>很多并发性专家事实上往往引导用户远离 volatile 变量，因为使用它们要比使用锁更加容易出错。然而，如果谨慎地遵循一些良好定义的模式，就能够在很多场合内安全地使用 volatile 变量。要始终牢记使用 volatile 的限制 —— 只有在状态真正独立于程序内其他内容时才能使用 volatile —— 这条规则能够避免将这些模式扩展到不安全的用例。</p>
<h2 id="模式-1：状态标志"><a href="#模式-1：状态标志" class="headerlink" title="模式 #1：状态标志"></a>模式 #1：状态标志</h2><p>也许实现 volatile 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。</p>
<p>很多应用程序包含了一种控制结构，形式为 “在还没有准备好停止程序时再执行一些工作”，如清单 2 所示：</p>
<p>清单 2. 将 volatile 变量作为状态标志使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> shutdownRequested;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123; shutdownRequested = <span class="keyword">true</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (!shutdownRequested) &#123; </span><br><span class="line">        <span class="comment">// do stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很可能会从循环外部调用 shutdown() 方法 —— 即在另一个线程中 —— 因此，需要执行某种同步来确保正确实现 shutdownRequested 变量的可见性。（可能会从 JMX 侦听程序、GUI 事件线程中的操作侦听程序、通过 RMI 、通过一个 Web 服务等调用）。然而，使用 synchronized 块编写循环要比使用清单 2 所示的 volatile 状态标志编写麻烦很多。由于 volatile 简化了编码，并且状态标志并不依赖于程序内任何其他状态，因此此处非常适合使用 volatile。</p>
<p>这种类型的状态标记的一个公共特性是：通常只有一种状态转换；shutdownRequested 标志从 false 转换为 true，然后程序停止。这种模式可以扩展到来回转换的状态标志，但是只有在转换周期不被察觉的情况下才能扩展（从 false 到 true，再转换到 false）。此外，还需要某些原子状态转换机制，例如原子变量。</p>
<h2 id="模式-2：一次性安全发布（one-time-safe-publication）"><a href="#模式-2：一次性安全发布（one-time-safe-publication）" class="headerlink" title="模式 #2：一次性安全发布（one-time safe publication）"></a>模式 #2：一次性安全发布（one-time safe publication）</h2><p>缺乏同步会导致无法实现可见性，这使得确定何时写入对象引用而不是原语值变得更加困难。在缺乏同步的情况下，可能会遇到某个对象引用的更新值（由另一个线程写入）和该对象状态的旧值同时存在。（这就是造成著名的双重检查锁定（double-checked-locking）问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象）。</p>
<p>实现安全发布对象的一种技术就是将对象引用定义为 volatile 类型。清单 3 展示了一个示例，其中后台线程在启动阶段从数据库加载一些数据。其他代码在能够利用这些数据时，在使用之前将检查这些数据是否曾经发布过。</p>
<p>清单 3. 将 volatile 变量用于一次性安全发布<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundFloobleLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> Flooble theFlooble;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initInBackground</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do lots of stuff</span></span><br><span class="line">        theFlooble = <span class="keyword">new</span> Flooble();  <span class="comment">// this is the only write to theFlooble</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeOtherClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; </span><br><span class="line">            <span class="comment">// do some stuff...</span></span><br><span class="line">            <span class="comment">// use the Flooble, but only if it is ready</span></span><br><span class="line">            <span class="keyword">if</span> (floobleLoader.theFlooble != <span class="keyword">null</span>) </span><br><span class="line">                doSomething(floobleLoader.theFlooble);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果 theFlooble 引用不是 volatile 类型，doWork() 中的代码在解除对 theFlooble 的引用时，将会得到一个不完全构造的 Flooble。</p>
<p>该模式的一个必要条件是：被发布的对象必须是线程安全的，或者是有效的不可变对象（有效不可变意味着对象的状态在发布之后永远不会被修改）。volatile 类型的引用可以确保对象的发布形式的可见性，但是如果对象的状态在发布后将发生更改，那么就需要额外的同步。</p>
<h2 id="模式-3：独立观察（independent-observation）"><a href="#模式-3：独立观察（independent-observation）" class="headerlink" title="模式 #3：独立观察（independent observation）"></a>模式 #3：独立观察（independent observation）</h2><p>安全使用 volatile 的另一种简单模式是：定期 “发布” 观察结果供程序内部使用。例如，假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 volatile 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。</p>
<p>使用该模式的另一种应用程序就是收集程序的统计信息。清单 4 展示了身份验证机制如何记忆最近一次登录的用户的名字。将反复使用 lastUser 引用来发布值，以供程序的其他部分使用。</p>
<p>清单 4. 将 volatile 变量用于多个独立观察结果的发布<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> String lastUser;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">authenticate</span><span class="params">(String user, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> valid = passwordIsValid(user, password);</span><br><span class="line">        <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">            User u = <span class="keyword">new</span> User();</span><br><span class="line">            activeUsers.add(u);</span><br><span class="line">            lastUser = user;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该模式是前面模式的扩展；将某个值发布以在程序内的其他地方使用，但是与一次性事件的发布不同，这是一系列独立事件。这个模式要求被发布的值是有效不可变的 —— 即值的状态在发布后不会更改。使用该值的代码需要清楚该值可能随时发生变化。</p>
<h2 id="模式-4：“volatile-bean”-模式"><a href="#模式-4：“volatile-bean”-模式" class="headerlink" title="模式 #4：“volatile bean” 模式"></a>模式 #4：“volatile bean” 模式</h2><p>volatile bean 模式适用于将 JavaBeans 作为“荣誉结构”使用的框架。在 volatile bean 模式中，JavaBean 被用作一组具有 getter 和/或 setter 方法 的独立属性的容器。volatile bean 模式的基本原理是：很多框架为易变数据的持有者（例如 HttpSession）提供了容器，但是放入这些容器中的对象必须是线程安全的。</p>
<p>在 volatile bean 模式中，JavaBean 的所有数据成员都是 volatile 类型的，并且 getter 和 setter 方法必须非常普通 —— 除了获取或设置相应的属性外，不能包含任何逻辑。此外，对于对象引用的数据成员，引用的对象必须是有效不可变的。（这将禁止具有数组值的属性，因为当数组引用被声明为 volatile 时，只有引用而不是数组本身具有 volatile 语义）。对于任何 volatile 变量，不变式或约束都不能包含 JavaBean 属性。清单 5 中的示例展示了遵守 volatile bean 模式的 JavaBean：</p>
<p>清单 5. 遵守 volatile bean 模式的 Person 对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> age;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> firstName; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> lastName; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="volatile-的高级模式"><a href="#volatile-的高级模式" class="headerlink" title="volatile 的高级模式"></a>volatile 的高级模式</h1><p>前面几节介绍的模式涵盖了大部分的基本用例，在这些模式中使用 volatile 非常有用并且简单。这一节将介绍一种更加高级的模式，在该模式中，volatile 将提供性能或可伸缩性优势。</p>
<p>volatile 应用的的高级模式非常脆弱。因此，必须对假设的条件仔细证明，并且这些模式被严格地封装了起来，因为即使非常小的更改也会损坏您的代码！同样，使用更高级的 volatile 用例的原因是它能够提升性能，确保在开始应用高级模式之前，真正确定需要实现这种性能获益。需要对这些模式进行权衡，放弃可读性或可维护性来换取可能的性能收益 —— 如果您不需要提升性能（或者不能够通过一个严格的测试程序证明您需要它），那么这很可能是一次糟糕的交易，因为您很可能会得不偿失，换来的东西要比放弃的东西价值更低。</p>
<h2 id="模式-5：开销较低的读－写锁策略"><a href="#模式-5：开销较低的读－写锁策略" class="headerlink" title="模式 #5：开销较低的读－写锁策略"></a>模式 #5：开销较低的读－写锁策略</h2><p>目前为止，您应该了解了 volatile 的功能还不足以实现计数器。因为 ++x 实际上是三种操作（读、添加、存储）的简单组合，如果多个线程凑巧试图同时对 volatile 计数器执行增量操作，那么它的更新值有可能会丢失。</p>
<p>然而，如果读操作远远超过写操作，您可以结合使用内部锁和 volatile 变量来减少公共代码路径的开销。清单 6 中显示的线程安全的计数器使用 synchronized 确保增量操作是原子的，并使用 volatile 保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及 volatile 读操作，这通常要优于一个无竞争的锁获取的开销。</p>
<p>清单 6. 结合使用 volatile 和 synchronized 实现 “开销较低的读－写锁”<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheesyCounter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Employs the cheap read-write lock trick</span></span><br><span class="line">    <span class="comment">// All mutative operations MUST be done with the 'this' lock held</span></span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之所以将这种技术称之为 “开销较低的读－写锁” 是因为您使用了不同的同步机制进行读写操作。因为本例中的写操作违反了使用 volatile 的第一个条件，因此不能使用 volatile 安全地实现计数器 —— 您必须使用锁。然而，您可以在读操作中使用 volatile 确保当前值的可见性，因此可以使用锁进行所有变化的操作，使用 volatile 进行只读操作。其中，锁一次只允许一个线程访问值，volatile 允许多个线程执行读操作，因此当使用 volatile 保证读代码路径时，要比使用锁执行全部代码路径获得更高的共享度 —— 就像读－写操作一样。然而，要随时牢记这种模式的弱点：如果超越了该模式的最基本应用，结合这两个竞争的同步机制将变得非常困难。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.cnblogs.com/sunrunzhi/p/3930297.html" target="_blank" rel="noopener">Java中volatile的作用以及用法</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-jtp06197.html" target="_blank" rel="noopener">正确使用 Volatile 变量</a></li>
<li><a href="http://ifeve.com/volatile/" target="_blank" rel="noopener">聊聊并发(1)深入分析Volatile的实现原理</a></li>
<li><a href="https://www.cnblogs.com/chengxiao/p/6528109.html" target="_blank" rel="noopener">谈谈Java中的volatile</a></li>
<li><a href="https://blog.csdn.net/alextan_/article/details/51284078" target="_blank" rel="noopener">什么叫内存屏障、编译屏障、内存对齐</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/02/Java并发-5-ThreadLocal/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="adamhand">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dethnote">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/02/Java并发-5-ThreadLocal/" itemprop="url">Java并发(5)--ThreadLocal</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-02T18:52:43+08:00">
                2019-01-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java并发之ThreadLocal"><a href="#Java并发之ThreadLocal" class="headerlink" title="Java并发之ThreadLocal"></a>Java并发之ThreadLocal</h1><hr>
<h1 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h1><p>首先说明，<strong>ThreadLocal与线程同步无关</strong>。ThreadLocal虽然提供了一种解决多线程环境下成员变量的问题，但是<strong>它并不是解决多线程共享变量的问题</strong>。</p>
<p>ThreadLocal类提供了一种<strong>线程局部变量(ThreadLocal)</strong>，即每一个线程都会保存一份变量副本，每个线程都可以独立地修改自己的变量副本，而不会影响到其他线程，是一种<strong>线程隔离</strong>的思想。</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>ThreadLocal提供四个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>get()方法是用来获取ThreadLocal在当前线程中保存的变量副本，set()用来设置当前线程中变量的副本，remove()用来移除当前线程中变量的副本，initialValue()是一个protected方法，一般是用来在使用时进行重写的，它是一个延迟加载方法。这四种方法都是基于ThreadLocalMap的。</p>
<h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p>ThreadLocal内部有一个静态内部类ThreadLocalMap，该内部类是实现线程隔离机制的关键。ThreadLocalMap提供了一种用键值对方式存储每一个线程的变量副本的方法，<strong>key为当前ThreadLocal对象，value则是对应线程的变量副本</strong>。该Map默认的大小是16，即能存储16个键值对，超过后会扩容。</p>
<p>具体源码如下：</p>
<h3 id="Entry类"><a href="#Entry类" class="headerlink" title="Entry类"></a>Entry类</h3><p>ThreadLocalMap其内部利用Entry来实现key-value的存储，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面代码中可以看出Entry的key就是ThreadLocal，而value就是值。同时，Entry也继承WeakReference，所以说Entry所对应key（ThreadLocal实例）的引用为一个弱引用。</p>
<h3 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 ThreadLocal 的散列值，查找对应元素在数组中的位置</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采用“线性探测法”，寻找合适位置</span></span><br><span class="line">    <span class="keyword">for</span> (ThreadLocal.ThreadLocalMap.Entry e = tab[i];</span><br><span class="line">        e != <span class="keyword">null</span>;</span><br><span class="line">        e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line"></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key 存在，直接覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key == null，但是存在值（因为此处的e != null），说明之前的ThreadLocal对象已经被回收了</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 用新元素替换陈旧的元素</span></span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ThreadLocal对应的key实例不存在也没有陈旧元素，new 一个</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap.Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cleanSomeSlots 清楚陈旧的Entry（key == null）</span></span><br><span class="line">    <span class="comment">// 如果没有清理陈旧的 Entry 并且数组中的元素大于了阈值，则进行 rehash</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ThreadLocalMap的set方法和Map的put方法差不多，但是有一点区别是：put方法处理哈希冲突使用的是<strong>链地址法</strong>，而set方法使用的<strong>开放地址法</strong>。</p>
<p>set()操作除了存储元素外，还有一个很重要的作用，就是replaceStaleEntry()和cleanSomeSlots()，这两个方法可以清除掉key == null 的实例，防止内存泄漏。在set()方法中还有一个变量很重要：threadLocalHashCode，定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br></pre></td></tr></table></figure></p>
<p>threadLocalHashCode是ThreadLocal的散列值，定义为final，表示ThreadLocal一旦创建其散列值就已经确定了，生成过程则是调用nextHashCode()：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>nextHashCode表示分配下一个ThreadLocal实例的threadLocalHashCode的值，HASH_INCREMENT则表示分配两个ThradLocal实例的threadLocalHashCode的增量。</p>
<h3 id="getEntry"><a href="#getEntry" class="headerlink" title="getEntry()"></a>getEntry()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于采用了开放定址法，所以当前key的散列值和元素在数组的索引并不是完全对应的，首先取一个探测数（key的散列值），如果所对应的key就是我们所要找的元素，则返回，否则调用getEntryAfterMiss()，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有一个重要的地方，当key == null时，调用了expungeStaleEntry()方法，该方法用于处理key == null，有利于GC回收，能够有效地避免内存泄漏。</p>
<h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前线程的成员变量 threadLocal</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从当前线程的ThreadLocalMap获取相对应的Entry</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取目标值        </span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先通过当前线程获取所对应的成员变量ThreadLocalMap，然后通过ThreadLocalMap获取当前ThreadLocal的Entry，最后通过所获取的Entry获取目标值result。</p>
<p>getMap()方法可以获取当前线程所对应的ThreadLocalMap，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="set-T-value"><a href="#set-T-value" class="headerlink" title="set(T value)"></a>set(T value)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取当前线程所对应的ThreadLocalMap，如果不为空，则调用ThreadLocalMap的set()方法，key就是当前ThreadLocal，如果不存在，则调用createMap()方法新建一个，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="initialValue"><a href="#initialValue" class="headerlink" title="initialValue()"></a>initialValue()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法定义为protected级别且返回为null，很明显是要子类实现它的，所以我们在使用ThreadLocal的时候一般都应该覆盖该方法。</p>
<p>注意：<strong>如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法。</strong></p>
<p>因为在上面的代码分析过程中，我们发现如果没有先set的话，即在map中查找不到对应的存储，则会通过调用setInitialValue方法返回i，而在setInitialValue方法中，有一个语句是T value = initialValue()， 而默认情况下，initialValue方法返回的是null。</p>
<h2 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的目的是减少内存的占用。当然，我们不需要显示调用该方法，因为一个线程结束后，它所对应的局部变量就会被垃圾回收。</p>
<h1 id="ThreadLocal使用示例"><a href="#ThreadLocal使用示例" class="headerlink" title="ThreadLocal使用示例"></a>ThreadLocal使用示例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeqCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; seqCount = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="comment">// 实现initialValue()</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextSeq</span><span class="params">()</span></span>&#123;</span><br><span class="line">        seqCount.set(seqCount.get() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> seqCount.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSeq</span><span class="params">()</span></span>&#123;</span><br><span class="line">        seqCount.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SeqCount seqCount = <span class="keyword">new</span> SeqCount();</span><br><span class="line"></span><br><span class="line">        SeqThread thread1 = <span class="keyword">new</span> SeqThread(seqCount);</span><br><span class="line">        SeqThread thread2 = <span class="keyword">new</span> SeqThread(seqCount);</span><br><span class="line">        SeqThread thread3 = <span class="keyword">new</span> SeqThread(seqCount);</span><br><span class="line">        SeqThread thread4 = <span class="keyword">new</span> SeqThread(seqCount);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SeqThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> SeqCount seqCount;</span><br><span class="line"></span><br><span class="line">        SeqThread(SeqCount seqCount)&#123;</span><br><span class="line">            <span class="keyword">this</span>.seqCount = seqCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">3</span> ; i++)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" seqCount :"</span> + seqCount.nextSeq());</span><br><span class="line">            &#125;</span><br><span class="line">            seqCount.removeSeq();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">1</span> seqCount :<span class="number">1</span></span><br><span class="line">Thread-<span class="number">3</span> seqCount :<span class="number">1</span></span><br><span class="line">Thread-<span class="number">2</span> seqCount :<span class="number">1</span></span><br><span class="line">Thread-<span class="number">0</span> seqCount :<span class="number">1</span></span><br><span class="line">Thread-<span class="number">2</span> seqCount :<span class="number">2</span></span><br><span class="line">Thread-<span class="number">3</span> seqCount :<span class="number">2</span></span><br><span class="line">Thread-<span class="number">1</span> seqCount :<span class="number">2</span></span><br><span class="line">Thread-<span class="number">3</span> seqCount :<span class="number">3</span></span><br><span class="line">Thread-<span class="number">2</span> seqCount :<span class="number">3</span></span><br><span class="line">Thread-<span class="number">0</span> seqCount :<span class="number">2</span></span><br><span class="line">Thread-<span class="number">1</span> seqCount :<span class="number">3</span></span><br><span class="line">Thread-<span class="number">0</span> seqCount :<span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<h1 id="ThreadLocal与内存泄漏"><a href="#ThreadLocal与内存泄漏" class="headerlink" title="ThreadLocal与内存泄漏"></a>ThreadLocal与内存泄漏</h1><h2 id="为什么会出现内存泄漏"><a href="#为什么会出现内存泄漏" class="headerlink" title="为什么会出现内存泄漏"></a>为什么会出现内存泄漏</h2><p>首先看一下运行时ThreadLocal变量的内存图：</p>
<center><br><img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/ThreadLocalMap.jpg"><br></center>

<p>运行时，会在栈中产生两个引用，指向堆中相应的对象。</p>
<p>可以看到，ThreadLocalMap使用ThreadLocal的弱引用作为key，这样一来，当ThreadLocal ref和ThreadLocal之间的强引用断开 时候，即ThreadLocal ref被置为null，下一次GC时，threadLocal对象势必会被回收，这样，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，<strong>比如使用线程池</strong>，线程使用完成之后会被放回线程池中，不会被销毁，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远无法回收，造成内存泄漏。</p>
<p>其实，ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施：在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap里所有key为null的value。</p>
<p>但是这些被动的预防措施并不能保证不会内存泄漏：</p>
<ul>
<li>使用static的ThreadLocal，延长了ThreadLocal的生命周期，可能导致的内存泄漏。</li>
<li>分配使用了ThreadLocal又不再调用get(),set(),remove()方法，那么就会导致内存泄漏。</li>
</ul>
<h2 id="为什么要使用弱引用？"><a href="#为什么要使用弱引用？" class="headerlink" title="为什么要使用弱引用？"></a>为什么要使用弱引用？</h2><p>使用弱引用，是为了更好地对ThreadLocal对象进行回收。如果使用强引用，当ThreadLocal ref = null的时候，意味着ThreadLocal对象已经没用了，ThreadLocal对象应该被回收，但由于Entry中还存着这对ThreadLocal对象的强引用，导致ThreadLocal对象不能回收，可能会发生内存泄漏。</p>
<h2 id="为什么不将value也设置成弱引用？"><a href="#为什么不将value也设置成弱引用？" class="headerlink" title="为什么不将value也设置成弱引用？"></a>为什么不将value也设置成弱引用？</h2><p>为什么呢？</p>
<h2 id="如何避免内存泄漏？"><a href="#如何避免内存泄漏？" class="headerlink" title="如何避免内存泄漏？"></a>如何避免内存泄漏？</h2><p><strong>每次使用完ThreadLocal，都调用它的remove()方法，清除数据。</strong></p>
<h1 id="ThreadLocal与脏读"><a href="#ThreadLocal与脏读" class="headerlink" title="ThreadLocal与脏读"></a>ThreadLocal与脏读</h1><p>前面说了，ThreadLocal中的set()、get()和remove()方法都会对key==null的value进行处理，其中set()和get()方法是将key==null的value置为null。但是如果ThreadLocal是static类型的，并且配合线程池使用，线程池会重用Thread对象，同时会重用与Thread绑定的ThreadLocal变量。倘若下一个线程不调用set()方法重新设置初始值，也不调用remove()方法处理旧值，直接调用get()方法获取，就会出现脏读问题。</p>
<p>例子如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirtyDataInThreadLocal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用固定大小为1的线程池，说明上一个线程属性会被下一个线程属性复用</span></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">            MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">            pool.execute(thread);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="comment">//第一个线程set后，没有remove，第二个线程也没有进行set操作</span></span><br><span class="line">                threadLocal.set(<span class="keyword">this</span>.getName() + <span class="string">", session info."</span>);</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName() + <span class="string">" 线程是 "</span> + threadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span>线程是 Thread-<span class="number">0</span>, session info.</span><br><span class="line">Thread-<span class="number">1</span>线程是 Thread-<span class="number">0</span>, session info.</span><br></pre></td></tr></table></figure>
<h1 id="ThreadLocal使用场景"><a href="#ThreadLocal使用场景" class="headerlink" title="ThreadLocal使用场景"></a>ThreadLocal使用场景</h1><h2 id="数据连接和Session管理"><a href="#数据连接和Session管理" class="headerlink" title="数据连接和Session管理"></a>数据连接和Session管理</h2><p>最常见的ThreadLocal使用场景为 用来解决 数据库连接、Session管理等。</p>
<p>如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder = <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(DB_URL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> connectionHolder.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123;</span><br><span class="line">    Session s = (Session) threadSession.get();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            s = getSessionFactory().openSession();</span><br><span class="line">            threadSession.set(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (HibernateException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ThreadLocal在Spring中的应用"><a href="#ThreadLocal在Spring中的应用" class="headerlink" title="ThreadLocal在Spring中的应用"></a>ThreadLocal在Spring中的应用</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://cmsblogs.com/?p=2442" target="_blank" rel="noopener">【死磕Java并发】—–深入分析ThreadLocal</a><br><a href="http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/" target="_blank" rel="noopener">深入分析 ThreadLocal内存泄漏问题</a><br><a href="https://www.cnblogs.com/dolphin0520/p/3920407.html" target="_blank" rel="noopener">Java并发编程：深入剖析ThreadLocal</a><br><a href="https://blog.csdn.net/xlgen157387/article/details/78297568" target="_blank" rel="noopener">Java多线程编程-（8）-多图深入分析ThreadLocal原理</a><br><a href="https://blog.csdn.net/shenlei19911210/article/details/50060223" target="_blank" rel="noopener">ThreadLocal类详解与源码分析</a><br><a href="https://www.cnblogs.com/jasongj/p/8079718.html" target="_blank" rel="noopener">ThreadLocal解决什么问题</a><br><a href="https://www.jianshu.com/p/ee8c9dccc953" target="_blank" rel="noopener">对ThreadLocal实现原理的一点思考</a><br><a href="https://blog.csdn.net/qq646040754/article/details/82493409" target="_blank" rel="noopener">ThreadLocalMap的enrty的key为什么要设置成弱引用</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">adamhand</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">52</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index-2.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">adamhand</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
